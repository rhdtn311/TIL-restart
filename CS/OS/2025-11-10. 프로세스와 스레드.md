# 목차

1.  [개요](https://www.google.com/search?q=%231-%EA%B0%9C%EC%9A%94)
2.  [프로세스(Process)](https://www.google.com/search?q=%232-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4process)
    * [2.1. 정의](https://www.google.com/search?q=%2321-%EC%A0%95%EC%9D%98)
    * [2.2. 메모리 구조](https://www.google.com/search?q=%2322-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)
3.  [멀티 프로세스(Multi-Process)](https://www.google.com/search?q=%233-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4multi-process)
    * [3.1. 정의](https://www.google.com/search?q=%2331-%EC%A0%95%EC%9D%98)
    * [3.2. 동시성(Concurrency)과 병렬성(Parallelism)](https://www.google.com/search?q=%2332-%EB%8F%99%EC%8B%9C%EC%84%B1concurrency%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1parallelism)
4.  [프로세스 관리와 CPU](https://www.google.com/search?q=%234-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC%EC%99%80-cpu)
    * [4.1. CPU 연산과 PC 레지스터](https://www.google.com/search?q=%2341-cpu-%EC%97%B0%EC%82%B0%EA%B3%BC-pc-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)
    * [4.2. 컨텍스트(Context)와 PCB](https://www.google.com/search?q=%2342-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8context%EC%99%80-pcb)
    * [4.3. 컨텍스트 스위치(Context Switch)](https://www.google.com/search?q=%2343-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%98context-switch)
5.  [스레드(Thread)](https://www.google.com/search?q=%235-%EC%8A%A4%EB%A0%88%EB%93%9Cthread)
    * [5.1. 정의](https://www.google.com/search?q=%2351-%EC%A0%95%EC%9D%98)
    * [5.2. 메모리 공유](https://www.google.com/search?q=%2352-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%B5%EC%9C%A0)
6.  [멀티 스레드의 필요성](https://www.google.com/search?q=%236-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1)
7.  [멀티 프로세스 vs. 멀티 스레드](https://www.google.com/search?q=%237-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-vs-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C)
8.  [실무 적용 사례: 스프링 애플리케이션](https://www.google.com/search?q=%238-%EC%8B%A4%EB%AC%B4-%EC%A0%81%EC%9A%A9-%EC%82%AC%EB%A1%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98)
    * [8.1. JVM 프로세스 실행](https://www.google.com/search?q=%2381-jvm-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8B%A4%ED%96%89)
    * [8.2. 프로세스 내부의 스레드 구성](https://www.google.com/search?q=%2382-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%8A%A4%EB%A0%88%EB%93%9C-%EA%B5%AC%EC%84%B1)
    * [8.3. 단일 코어 환경의 동작 예시](https://www.google.com/search?q=%2383-%EB%8B%A8%EC%9D%BC-%EC%BD%94%EC%96%B4-%ED%99%98%EA%B2%BD%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%98%88%EC%8B%9C)
9.  [요약](https://www.google.com/search?q=%239-%EC%9A%94%EC%95%BD)

-----

이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

### 1\. 개요

현대 운영체제는 여러 프로그램을 동시에 실행하기 위해 \*\*프로세스(Process)\*\*와 \*\*스레드(Thread)\*\*라는 핵심 개념을 사용한다. 이 문서는 프로세스와 스레드의 정의, 동작 방식, 그리고 이 개념이 **스프링 부트 애플리케이션**과 같은 실제 환경에서 어떻게 적용되는지 기술한다.

### 2\. 프로세스(Process)

#### 2.1. 정의

> **프로세스**란 디스크에 존재하는 프로그램(실행 파일)이 메모리에 적재되어, CPU를 할당받아 실행되는 상태를 의미한다.

#### 2.2. 메모리 구조

**메모리**는 CPU가 직접 접근할 수 있는 기억장치이며, 프로그램이 CPU에 의해 실행되려면 반드시 메모리에 적재되어야 한다. 프로세스에 할당되는 메모리 공간은 다음과 같이 구분된다.

* **Code 영역:** 실행할 프로그램의 코드가 저장되는 영역이다.
* **Data 영역:** 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역이다.
* **Stack 영역:** 함수 호출 시 생성되는 지역 변수와 매개변수 등이 저장되는 임시 메모리 영역이다.
* **Heap 영역:** 프로그래머가 코드를 통해 직접 공간을 할당(allocate)하고 해제(deallocate)하는 메모리 영역이다.

-----

### 3\. 멀티 프로세스(Multi-Process)

#### 3.1. 정의

> **멀티 프로세스**란 2개 이상의 프로세스가 동시에 실행되는 것을 의미한다.

여기서 '동시'라는 개념은 **동시성**과 **병렬성**을 모두 포함한다.

#### 3.2. 동시성(Concurrency)과 병렬성(Parallelism)

* **동시성 (Concurrency):**
    * CPU 코어가 1개일 때, 여러 프로세스를 매우 짧은 시간 동안 번갈아 가면서 연산하는 **시분할 시스템(Time-sharing System)** 방식이다.
    * 논리적으로는 동시에 실행되는 것처럼 보이지만, 물리적으로는 한순간에 하나의 프로세스만 처리된다.
* **병렬성 (Parallelism):**
    * CPU 코어가 여러 개일 때, 각각의 코어가 각각의 프로세스를 맡아 연산함으로써 여러 프로세스가 물리적으로 동시에 실행되는 것이다.

-----

### 4\. 프로세스 관리와 CPU

#### 4.1. CPU 연산과 PC 레지스터

CPU는 \*\*PC 레지스터(Program Counter Register)\*\*가 가리키고 있는 명령어를 읽어들여 연산을 진행한다. PC 레지스터에는 다음에 실행될 명령어의 주소값이 저장되어 있다.

운영체제는 PC 레지스터가 가리키는 곳을 변경하는 방식으로 여러 프로세스를 번갈아 가며 실행한다.

#### 4.2. 컨텍스트(Context)와 PCB

> \*\*컨텍스트(Context)\*\*란 프로세스가 현재 어떤 상태로 수행되고 있는지에 대한 총체적인 정보를 의미한다.

이러한 컨텍스트 정보는 \*\*PCB(Process Control Block)\*\*라는 자료구조에 저장된다.

* **PCB (Process Control Block)**
    * 운영체제가 각 프로세스를 식별하고 관리하기 위해 사용하는 자료구조다.
    * 프로세스의 중요한 정보가 포함되어 있어, 일반 사용자가 접근하지 못하도록 보호된다. (일부 운영체제에서는 커널 스택에 저장)
    * 일반적으로 다음과 같은 정보가 저장된다.
        * Process State (프로세스 상태)
        * Process Number (프로세스 식별자)
        * **Program Counter (다음에 실행할 명령어 주소)**
        * Registers (CPU 레지스터 정보)
        * Memory Limits (메모리 할당 정보)

#### 4.3. 컨텍스트 스위치(Context Switch)

> **컨텍스트 스위치**란 한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 과정을 말한다.

이때, 운영체제는 현재 실행 중이던 이전 프로세스의 상태(Context)를 해당 프로세스의 **PCB에 저장**하고, 새로 실행할 프로세스의 **PCB에서 보관된 상태를 복구**하는 작업을 수행한다.

-----

### 5\. 스레드(Thread)

#### 5.1. 정의

> \*\*스레드(Thread)\*\*란 한 프로세스 내에서 실행되는 동작(실행 흐름)의 단위를 의미한다.

CPU 입장에서 실제로 실행하는 작업 단위는 스레드다. 프로세스는 "실행 중인 프로그램"이라는 개념적인 단위이며, CPU가 직접 다루는 것은 프로세스 내부의 실행 흐름인 스레드다.

따라서 모든 프로세스는 반드시 하나 이상의 스레드(일반적으로 **메인 스레드**)를 가져야 한다.

#### 5.2. 메모리 공유

각 스레드는 자신이 속한 프로세스의 메모리 영역 중 **Stack 영역을 제외**한 **Code, Data, Heap 영역을 공유**한다. 각 스레드는 별도의 Stack 영역을 할당받아 사용한다.

-----

### 6\. 멀티 스레드의 필요성

CPU 코어 하나는 한순간에 하나의 스레드만 실행할 수 있음에도 불구하고, 하나의 프로세스가 멀티 스레드로 구성되는 주된 이유는 **작업의 동시성(Concurrency) 확보**와 **자원 효율성** 때문이다.

* **단일 스레드의 한계:**
    * 웹 애플리케이션에서 스레드가 하나라면, 한 사용자의 요청을 처리하는 동안 다른 사용자의 요청은 모두 대기 상태에 놓이게 된다.
    * 특히, 사용자 A의 요청을 처리하는 스레드가 DB 조회나 외부 API 호출과 같은 **I/O(Input/Output) 작업**을 수행하며 **대기(Block) 상태**에 빠진다면, CPU가 유휴 상태임에도 불구하고 다른 사용자(B)의 요청을 전혀 처리할 수 없게 된다.
* **멀티 스레드의 이점 (동시성):**
    * 멀티 스레드 환경에서는, 사용자 A의 요청을 처리하던 스레드가 I/O 대기 상태에 빠지면, CPU가 즉시 사용자 B의 요청을 처리하는 다른 스레드로 **컨텍스트 스위칭**을 수행한다.
    * 이를 통해 단일 코어 환경일지라도 여러 사용자의 요청을 **동시에(Concurrent)** 처리하여 시스템 전체의 응답성과 처리량을 높일 수 있다.

-----

### 7\. 멀티 프로세스 vs. 멀티 스레드

| 항목 | 멀티 프로세스 (Multi-Process) | 멀티 스레드 (Multi-Thread) |
| :--- | :--- | :--- |
| **메모리** | 독립적인 메모리 공간 할당 (Code, Data, Heap, Stack) | Stack을 제외한 메모리 영역 공유 (Code, Data, Heap) |
| **자원 소모** | 더 많은 메모리 공간과 CPU 시간 차지 | 더 적은 메모리 공간 차지 (자원 공유) |
| **컨텍스트 스위칭** | 비용이 크고 속도가 느림 (메모리 전체 교체) | 비용이 적고 속도가 빠름 (Stack, PC 등 일부만 교체) |
| **안정성** | 하나의 프로세스 장애가 다른 프로세스에 영향 없음 | 하나의 스레드 장애가 전체 프로세스에 영향을 줄 수 있음 |
| **난이도** | 통신(IPC)이 복잡함 | 데이터 공유가 쉬우나 **동기화 문제** 발생 가능 |

-----

### 8. 직접 확인한 예시 (스프링 애플리케이션)

#### 8.1. JVM 프로세스 실행

스프링 부트 애플리케이션을 실행하면, 운영체제는 이 애플리케이션을 실행하기 위한 **JVM(Java Virtual Machine) 프로세스**를 하나 생성한다. 즉, 운영체제 입장에서 스프링 부트 애플리케이션 전체는 **하나의 프로세스**로 인식된다.

#### 8.2. 프로세스 내부의 스레드 구성

이 JVM 프로세스 내부에는 다양한 목적을 가진 여러 스레드가 동시에 실행된다.

* **메인 스레드 (Main Thread):**
    * 프로세스 시작 시 가장 먼저 실행되며, 스프링 컨텍스트를 초기화하고, 빈(Bean)을 생성하며, 내장 웹 서버(예: Tomcat)를 구동하는 역할을 수행한다.
* **GC 스레드 (Garbage Collector Threads):**
    * Heap 메모리를 관리(정리)하기 위해 백그라운드에서 동작하는 스레드다.
* **웹 서버 관련 스레드 (내장 Tomcat 기준):**
    * **Acceptor 스레드:** 네트워크 포트(기본 8080)에서 들어오는 신규 HTTP 연결 요청을 감지하고 수신한다.
    * **Worker 스레드 (스레드 풀):** Acceptor 스레드가 받은 요청을 실제 비즈니스 로직(Dispatcher Servlet -\> Controller -\> Service ...)으로 처리하는 스레드다. 요청마다 새 스레드를 생성하는 것이 아니라, 미리 생성된 \*\*스레드 풀(Thread Pool)\*\*에서 스레드를 빌려와 사용하고 반납한다.
* **추가 스레드:**
    * 개발자가 `@Async`, `@Scheduled`, `ExecutorService` 등을 사용하여 명시적으로 생성한 스레드 풀에서 비동기 작업을 처리하는 스레드다.

#### 8.3. 단일 코어 환경의 동작 예시

다음은 단일 코어 CPU 환경에서 여러 프로세스와 스레드가 어떻게 처리되는지 가정한 상황이다.

* **상황:**

    * CPU: 1 코어
    * 실행 중인 프로세스: 스프링 부트 앱, 크롬 브라우저, 채팅 프로그램
    * 이벤트: 사용자의 HTTP 요청이 스프링 부트 앱으로 들어옴.

* **CPU 관점 (시분할 스케줄링):**

    * CPU 코어는 한순간에 하나의 스레드만 실행할 수 있다.
    * 운영체제(OS) 스케줄러가 매우 짧은 시간(Time Slice) 단위로 여러 스레드를 빠르게 번갈아 가며 실행시킨다. (동시성)

* **요청 처리 흐름 예시:**

    * 스프링 부트 앱의 **Acceptor 스레드**가 요청을 수신하고, **Worker 스레드 풀**의 **Worker Thread 1**에게 작업을 할당한다.

<!-- end list -->

```less
Time 0ms: CPU -> Spring Boot Worker Thread 1 (요청 처리 시작)
Time 1ms: CPU -> Chrome Renderer Thread (웹 페이지 렌더링)
Time 2ms: CPU -> Spring Boot Worker Thread 1 (요청의 다음 처리 단계)
Time 3ms: CPU -> 채팅 프로그램 메시지 처리 Thread
Time 4ms: CPU -> Spring Boot Worker Thread 1 (DB 조회 요청 후 대기 상태 진입)
Time 5ms: CPU -> Chrome Network Thread (리소스 다운로드)
...
```

* **결론:**
    * 위와 같이 CPU는 극히 짧은 시간 단위로 여러 프로세스에 속한 여러 스레드들을 번갈아 가며 실행한다.
    * 비록 물리적으로는 단일 코어에서 순차적으로 처리되지만, 운영체제 스케줄러의 빠른 **컨텍스트 스위칭** 덕분에 사용자는 모든 프로그램이 동시에 실행되는 것처럼 느끼게 된다.

-----

### 9\. 요약

**프로세스**는 메모리에서 실행 중인 프로그램을 의미하며, **스레드**는 그 프로세스 내부에서 실제 작업을 수행하는 단위다. 하나의 프로세스는 여러 스레드를 가질 수 있으며, 이를 **멀티 스레딩**이라 한다. 멀티 스레딩은 I/O 대기 시 CPU가 다른 스레드를 실행할 수 있게 하여(동시성), 시스템의 전체 처리 효율을 극대화한다. 스프링 부트 애플리케이션은 스레드 풀(Worker Threads)을 활용한 멀티 스레드 모델을 기반으로 다수의 사용자 요청을 동시에 처리한다.
# 목차

1. **개요**

2. **컴포지트 패턴 (Composite Pattern)**

3. **옵저버 패턴 (Observer Pattern)**

4. **커맨드 패턴 (Command Pattern)**

5. **데코레이터 패턴 (Decorator Pattern)**

6. **퍼사드 패턴 (Facade Pattern)**

7. **실무 적용 사례**

8. **요약**


---

> 이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 개요

본 문서는 소프트웨어 설계에서 자주 사용되는 주요 구조(Structural) 및 행동(Behavioral) 디자인 패턴 5가지를 정의하고, 각 패턴의 특징, 구성 요소, 그리고 코틀린(Kotlin) 기반의 구현 예제를 다룬다.

---

### 2. 컴포지트 패턴 (Composite Pattern)

객체들을 트리 구조로 구성하여 **‘부분’과 ‘전체’를 나타내는 계층 구조**를 만드는 구조 디자인 패턴이다.

#### 2.1 주요 특징

- **일관된 취급:** 클라이언트는 개별 객체(Leaf)와 복합 객체(Composite)를 구별하지 않고 동일한 타입(인터페이스)으로 다룰 수 있다.

- **재귀적 구조:** 복합 객체는 자식으로 또 다른 복합 객체나 단일 객체를 포함할 수 있어 트리 구조를 형성한다.


#### 2.2 사용 상황

- 파일 시스템(폴더/파일), 조직도, GUI 메뉴 구조 등 계층적 데이터 표현이 필요할 때 사용한다.


#### 2.3 핵심 구성 요소

- **Component:** 모든 객체가 구현해야 하는 공통 인터페이스.

- **Leaf:** 하위 요소가 없는 기본 객체로, 실제 동작을 수행한다.

- **Composite:** 하위 요소를 자식으로 가지며, 작업을 자식들에게 위임하거나 반복 수행한다.


#### 2.4 구현 예시: 파일 시스템
```koltin
// Component: 파일과 폴더가 공통으로 가질 동작을 정의
interface FileSystemNode {
    val name: String
    fun getSize(): Int
    fun printDetails(indent: String = "")
}

// Leaf: 더 이상 하위 요소를 가질 수 없는 파일
class File(
    override val name: String,
    private val size: Int
) : FileSystemNode {

    override fun getSize(): Int = size

    override fun printDetails(indent: String) {
        println("$indent📄 $name (${getSize()} KB)")
    }
}

// Composite: 하위 요소(File 또는 Directory)를 포함하는 폴더
class Directory(
    override val name: String
) : FileSystemNode {

    // 자식 노드들을 저장하는 리스트 (Component 타입을 저장)
    private val children = mutableListOf<FileSystemNode>()

    fun add(node: FileSystemNode) {
        children.add(node)
    }

    fun remove(node: FileSystemNode) {
        children.remove(node)
    }

    // 폴더의 크기는 포함된 모든 자식들의 크기 합계 (재귀적 호출)
    override fun getSize(): Int {
        return children.sumOf { it.getSize() }
    }

    override fun printDetails(indent: String) {
        println("$indent📂 $name (Total: ${getSize()} KB)")
        children.forEach { child ->
            child.printDetails("$indent  ") // 들여쓰기를 추가하여 계층 구조 표현
        }
    }
}
```

#### 2.5 사용 예제
```kotlin
fun main() {
    // 1. Leaf 객체(파일) 생성
    val file1 = File("Resume.pdf", 100)
    val file2 = File("Photo.png", 500)
    val file3 = File("Notes.txt", 10)

    // 2. Composite 객체(폴더) 생성 및 구성
    val subFolder = Directory("My Pictures")
    subFolder.add(file2) // 폴더에 파일 추가

    val rootFolder = Directory("Root")
    rootFolder.add(file1)       // 루트에 파일 추가
    rootFolder.add(subFolder)   // 루트에 또 다른 폴더 추가
    rootFolder.add(file3)       // 루트에 파일 추가

    // 3. 클라이언트는 폴더인지 파일인지 구분할 필요 없이 동일한 메서드 호출
    println("--- File System Structure ---")
    rootFolder.printDetails()
   
    println("\n--- Size Calculation ---")
    println("Size of 'My Pictures': ${subFolder.getSize()} KB")
    println("Size of 'Root': ${rootFolder.getSize()} KB")
}
```

---

### 3. 옵저버 패턴 (Observer Pattern)

어떤 객체(Subject)의 상태가 변할 때, 그와 연관된 객체(Observer)들에게 **자동으로 알림을 보내는 행동** 디자인 패턴이다.

#### 3.1 사용 상황

- 한 객체의 상태 변화에 따라 다른 객체들이 동적으로 반응해야 할 때 사용한다.

- 알림을 보내는 주체가 수신자가 누구인지, 몇 명인지 알 필요가 없는 **느슨한 결합(Loose Coupling)**이 필요할 때 유용하다.


#### 3.2 핵심 구성 요소

- **Subject (주체/발행자):** 상태를 관리하며 옵저버를 등록 및 해제하는 인터페이스를 제공한다.

- **Observer (관찰자/구독자):** 주체의 변화를 통지받는 인터페이스를 정의한다.


#### 3.3 구현 예시: 유튜브 구독 시스템

```kotlin
// Observer: 알림을 받을 수 있는 모든 객체의 공통 인터페이스
interface Subscriber {
    fun onVideoUploaded(videoTitle: String)
}

// Subject: 구독자들을 관리하고 알림을 보내는 주체
class YouTuber(val name: String) {
    // 구독자 목록 (느슨한 결합: 구체적인 클래스가 아닌 인터페이스에 의존)
    private val subscribers = mutableListOf<Subscriber>()

    // 구독하기
    fun subscribe(subscriber: Subscriber) {
        subscribers.add(subscriber)
        println("새로운 구독자가 추가되었습니다.")
    }

    // 구독 취소
    fun unsubscribe(subscriber: Subscriber) {
        subscribers.remove(subscriber)
        println("구독자가 떠났습니다.")
    }

    // 새 영상 업로드 (상태 변경 -> 알림 발송)
    fun uploadVideo(title: String) {
        println("[$name] 채널에 새 영상 업로드: $title")
        notifySubscribers(title)
    }

    // 모든 구독자에게 알림 전송
    private fun notifySubscribers(title: String) {
        subscribers.forEach { it.onVideoUploaded(title) }
    }
}

// 일반 사용자 구독자
class UserSubscriber(val nickname: String) : Subscriber {
    override fun onVideoUploaded(videoTitle: String) {
        println("$nickname 님, 새 영상이 올라왔어요: $videoTitle")
    }
}

// 알림 봇 구독자 (다른 형태의 구현체)
class NotificationBot : Subscriber {
    override fun onVideoUploaded(videoTitle: String) {
        println("[System] 로그 기록: 영상 '$videoTitle' 알림 전송됨.")
    }
}
```

#### 3.4 플랫폼별 구현 예시

1) Kotlin 표준 라이브러리 활용

Delegates.observable을 사용하여 프로퍼티 변경 시 자동으로 로직을 실행할 수 있다.

```kotlin
import kotlin.properties.Delegates

class StockTicker {
    // 가격이 변할 때마다 자동으로 블록 안의 코드가 실행됨
    var price: Int by Delegates.observable(0) { prop, old, new ->
        println("주가 변동! $old -> $new")
        // 여기에 알림 로직을 추가
    }
}
```

2) Spring Framework 활용

ApplicationEventPublisher와 @EventListener를 사용하여 컴포넌트 간 이벤트를 처리한다.

```kotlin
// 1. 이벤트 정의
data class OrderCreatedEvent(val orderId: String)

// 2. 이벤트 발행 (Subject)
@Service
class OrderService(private val eventPublisher: ApplicationEventPublisher) {
    fun createOrder() {
        // 주문 로직 수행...
        eventPublisher.publishEvent(OrderCreatedEvent("ORD-123")) // 알림 발송
    }
}

// 3. 이벤트 구독 (Observer)
@Component
class EmailService {
    @EventListener
    fun handleOrderCreated(event: OrderCreatedEvent) {
        println("📧 주문 완료 이메일 발송: ${event.orderId}")
    }
}
```

#### 3.5 장단점 비교

|**장점**|**단점**|
|---|---|
|**느슨한 결합:** 주체와 관찰자가 서로의 구체적 구현을 알 필요가 없다.|**제어의 어려움:** 알림 전송 순서를 보장하기 어렵다.|
|**개방-폐쇄 원칙(OCP):** 관찰자를 추가해도 주체 코드는 수정할 필요가 없다.|**메모리 누수:** 관찰자를 명시적으로 해제(unsubscribe)하지 않으면 메모리가 해제되지 않을 수 있다.|

---

### 4. 커맨드 패턴 (Command Pattern)

**요청(Request)을 객체로 캡슐화**하여, 요청을 파라미터화하거나 저장, 로깅, 취소(Undo)할 수 있게 만드는 행동 디자인 패턴이다.

![Command design pattern UML class diagram 이미지](https://encrypted-tbn3.gstatic.com/licensed-image?q=tbn:ANd9GcThDmZ0GbaTHTt_LoR-93PsMJzVFZUGzLiKCj65DEEPjYR82k9r_Crq1PGJRGF2pbehSk7rrahqOCR4OVoXQW5jD3-J0Vf1DQH4c2soRElGeohEq2E)

Getty Images

#### 4.1 핵심 가치

- **캡슐화:** 요청 내역을 객체 안에 숨겨 추상화한다.

- **유연성:** 요청을 큐(Queue)에 저장하거나, 실행 취소 및 재실행 기능을 구현하기 용이하다.

- **의존성 제거:** 작업을 요청하는 객체(Invoker)와 수행하는 객체(Receiver)를 분리한다.


#### 4.2 핵심 구성 요소

- **Command:** 실행될 기능을 정의하는 인터페이스 (`execute()` 메서드 포함).

- **ConcreteCommand:** 실제 요청 로직을 구현하며, Receiver를 호출한다.

- **Receiver:** 실제 작업을 수행하는 비즈니스 로직 객체.

- **Invoker:** 명령을 발송하는 역할(예: 리모컨).


#### 4.3 구현 예시: 스마트 리모컨

```kotlin
// 1. Command
interface Command {
    fun execute()
}

// 2. Receiver
class Light {
    fun turnOn() = println("💡 Light ON")
    fun turnOff() = println("💡 Light OFF")
}

// 3. ConcreteCommand
class LightOnCommand(private val light: Light) : Command {
    override fun execute() {
        light.turnOn()
    }
}

class LightOffCommand(private val light: Light) : Command {
    override fun execute() {
        light.turnOff()
    }
}

// 4. Invoker
class RemoteControl {
    private val history = mutableListOf<Command>()

    fun press(command: Command) {
        command.execute()
        history += command
    }
}
```

---

### 5. 데코레이터 패턴 (Decorator Pattern)

객체에 **추가적인 기능을 동적으로 덧붙일 때** 사용하는 구조 디자인 패턴이다. 상속을 통한 기능 확장의 경직성을 해결한다.

#### 5.1 사용 이유

단순 상속으로 기능을 확장할 경우, 기능 조합의 수만큼 하위 클래스가 폭발적으로 증가하는 문제(Class Explosion)를 방지하기 위함이다.

#### 5.2 핵심 구성 요소

- **Component:** 기본 기능을 정의하는 인터페이스.

- **ConcreteComponent:** 기본 기능을 실제로 구현하는 객체.

- **Decorator:** Component를 감싸는 추상 클래스로, 기존 컴포넌트의 참조를 가진다.

- **ConcreteDecorator:** 실제 추가 기능을 구현하는 장식자.


#### 5.3 구현 예시: 알림 서비스

```kotlin
// 기본 인터페이스
interface Notifier {
    fun send(message: String)
}

// 기본 구현체
class BasicNotifier : Notifier {
    override fun send(message: String) {
        println("기본 알림: $message")
    }
}

// 데코레이터 추상 클래스
open class NotifierDecorator(
    private val notifier: Notifier
) : Notifier {

    override fun send(message: String) {
        notifier.send(message) // 기존 기능 호출
    }
}

// Slack 데코레이터
class SlackNotifierDecorator(
    notifier: Notifier
) : NotifierDecorator(notifier) {

    override fun send(message: String) {
        super.send(message)
        println("Slack 알림 전송: $message")
    }
}

// Email 데코레이터
class EmailNotifierDecorator(
    notifier: Notifier
) : NotifierDecorator(notifier) {

    override fun send(message: String) {
        super.send(message)
        println("Email 알림 전송: $message")
    }
}
```

> **참고:** 데코레이터 패턴은 기존 객체의 행동을 확장하는 데 초점을 맞추는 반면, 프록시(Proxy) 패턴은 접근 제어나 지연 로딩 등 객체 접근을 제어하는 데 초점을 맞춘다는 차이가 있다.

---

### 6. 퍼사드 패턴 (Facade Pattern)

복잡한 서브시스템(여러 객체, API 호출)을 감추고, 클라이언트에게는 **단순화된 통합 인터페이스(Facade)**를 제공하는 패턴이다.

#### 6.1 사용 이유

- 복잡한 라이브러리나 프레임워크 사용 시 진입 장벽을 낮추기 위해 사용한다.

- 시스템의 계층(Layer)을 명확히 구분하여 결합도를 낮추고자 할 때 유용하다.


#### 6.2 구현 예시: 지원자 등록 시스템

```kotlin
// 서브시스템들
class CandidateService {
    fun createCandidate(name: String) {
        println("지원자 생성: $name")
    }
}

class ResumeService {
    fun uploadResume(file: String) {
        println("이력서 업로드: $file")
    }
}

class EmailService {
    fun sendWelcomeEmail(email: String) {
        println("지원완료 메일 전송: $email")
    }
}

// 퍼사드 (단순화된 인터페이스 제공)
class CandidateRegistrationFacade(
    private val candidateService: CandidateService,
    private val resumeService: ResumeService,
    private val emailService: EmailService,
) {
    fun register(name: String, email: String, resumePath: String) {
        candidateService.createCandidate(name)
        resumeService.uploadResume(resumePath)
        emailService.sendWelcomeEmail(email)
        println("지원자 등록 완료")
    }
}
```

---

### 7. 실무 적용 사례

(적용 후 반영 예정)


---

### 8. 요약

본 문서는 소프트웨어의 유연성과 유지보수성을 높이는 5가지 핵심 디자인 패턴을 다루었다.

컴포지트는 계층 구조 처리를, 옵저버는 상태 변화에 대한 자동 알림을, 커맨드는 요청의 캡슐화를 담당한다. 또한 데코레이터는 유연한 기능 확장을 가능하게 하며, 퍼사드는 복잡한 시스템을 단순하게 추상화하여 제공한다. 이러한 패턴들은 적재적소에 활용될 때 코드의 결합도를 낮추고 확장성을 극대화한다.

---

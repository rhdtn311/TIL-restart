# 리액티브 프로그래밍(Reactive Programming)

## 목차

1. 개요
2. 핵심 철학 및 개념 상세
3. 리액티브 스트림즈(Reactive Streams) 표준
4. 동작 원리: Blocking vs Non-Blocking
5. Spring WebFlux와 Project Reactor
6. 코드 심층 분석 (명령형 vs 리액티브)
7. 도입 시 고려사항 (장단점)
8. 실무 적용 사례
9. 요약

---

이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 개요

#### 1.1 정의

리액티브 프로그래밍은 **데이터 스트림(Data Stream)과 변화의 전파**에 중점을 둔 비동기 프로그래밍 패러다임이다. 정적인 데이터 처리가 아닌, 데이터가 발생하거나 변경되는 이벤트를 지속적으로 관찰(Observe)하고 이에 즉각적으로 반응(React)하는 것을 목표로 한다.

#### 1.2 패러다임의 변화: 엑셀(Excel) 비유

리액티브 프로그래밍의 본질은 엑셀의 동작 방식과 매우 유사하다. 이를 통해 명령형 프로그래밍과의 차이를 직관적으로 이해할 수 있다.

* **명령형 프로그래밍 (Pull 방식)**
* A1 셀에 10, B1 셀에 20이 있고, C1 셀에 `A1 + B1`의 결과인 30을 저장한다.
* 이후 A1을 30으로 변경하더라도, C1은 여전히 30이다.
* 개발자가 명시적으로 "C1을 다시 계산해"라고 명령을 내려야만 값이 갱신된다.


* **리액티브 프로그래밍 (Push 방식)**
* C1 셀에 `=SUM(A1, B1)`이라는 수식(구독)을 선언한다.
* A1이 30으로 변경되는 **이벤트가 발생**하면, C1은 즉시 이를 감지하고 50으로 **자동 갱신**된다.
* **핵심:** C1은 A1과 B1의 데이터 변화를 **구독(Subscribe)**하고 있으며, 데이터는 변화하는 순간 전파된다.



---

### 2. 핵심 철학 및 개념 상세

리액티브 프로그래밍은 모든 것을 '스트림'으로 바라보는 관점의 전환이 필요하다.

#### 2.1 데이터 스트림 (Data Stream)

데이터 스트림은 시간의 흐름에 따라 연속적으로 발생하는 이벤트의 흐름이다. 리액티브 프로그래밍에서는 정적인 변수뿐만 아니라, 다음과 같은 동적인 요소들도 모두 스트림으로 취급한다.

* **UI 이벤트:** 마우스 클릭, 키보드 입력, 터치 이벤트
* **네트워크 I/O:** 서버로부터 도착하는 HTTP 응답, WebSocket 메시지
* **내부 로직:** 변수 값의 변경, 에러 발생, 작업 완료 신호

이 모든 데이터는 **수도관(Pipe)을 흐르는 물**과 같다. 개발자는 이 파이프 중간에 필터(Filter), 변환기(Map), 합류 지점(Merge/Zip) 등의 **연산자(Operator)**를 설치하여 데이터를 가공한다.

#### 2.2 비동기(Asynchronous)와 논블로킹(Non-Blocking)

* **비동기:** 작업을 지시한 후 결과를 기다리지 않고 다음 작업을 즉시 수행하는 방식이다. "나중에 완료되면 알려줘"라고 위임하는 것과 같다.
* **논블로킹:** 작업이 완료될 때까지 실행 흐름(스레드)을 멈추지(Block) 않는다. 이는 제한된 시스템 자원으로 더 많은 요청을 처리할 수 있게 하는 핵심 기술이다.

#### 2.3 배압 (Backpressure)

**"소비자가 감당할 수 있는 만큼만 데이터를 요청하는 메커니즘"**이다.

* **문제 상황:** 발행자(Publisher)가 1초에 10,000개의 데이터를 보내는데, 구독자(Subscriber)는 1초에 100개밖에 처리하지 못한다면? 메모리 오버플로우(OOM)가 발생하거나 시스템이 다운된다.
* **해결:** 구독자는 발행자에게 "지금은 50개만 보내줘"라고 요청(Request)하고, 발행자는 그에 맞춰 속도를 조절한다. 이것이 리액티브 프로그래밍이 시스템 안정성을 보장하는 방법이다.

---

### 3. 리액티브 스트림즈(Reactive Streams) 표준

Java 생태계에서 리액티브 프로그래밍을 구현하기 위한 표준 사양(Interface)은 다음 4가지 핵심 요소로 구성된다.

| 구성 요소 | 역할 및 설명 |
| --- | --- |
| **Publisher (발행자)** | 데이터 스트림을 생성하고 구독자에게 데이터를 발행(`emit`)하는 주체다. |
| **Subscriber (구독자)** | 발행자에게 구독을 요청하고, 전달받은 데이터를 소비(처리)한다. |
| **Subscription (구독)** | 발행자와 구독자 사이의 연결 고리다. 구독자가 데이터 요청 개수를 조절(`request`)하거나 구독을 취소(`cancel`)할 때 사용한다. |
| **Processor (처리기)** | 발행자와 구독자의 기능을 모두 가진다. 데이터를 받아 가공한 후 다시 하위 구독자에게 전달하는 중간 단계 역할을 한다. |

---

### 4. 동작 원리: Blocking vs Non-Blocking

#### 4.1 명령형 방식 (Blocking I/O)

* **구조:** 요청 당 하나의 스레드(Thread per Request) 모델.
* **동작:** 스레드가 DB에 쿼리를 보내면, DB가 응답을 줄 때까지 스레드는 **아무 일도 하지 못하고 대기(Blocking)** 상태에 빠진다.
* **한계:**
  * 동시 접속자가 늘어나면 스레드 수가 기하급수적으로 늘어난다.
  * 스레드 생성 및 전환(Context Switching)에 막대한 CPU 자원이 소모된다.
  * I/O 대기 시간 동안 값비싼 스레드 자원이 낭비된다.



#### 4.2 리액티브 방식 (Non-Blocking I/O)

* **구조:** 이벤트 루프(Event Loop) 기반의 적은 스레드 운용.
* **동작:**
  1. 스레드가 DB 조회 요청을 보낸 뒤, **즉시 리턴**하여 다른 요청을 처리하러 떠난다.
  2. DB 작업이 백그라운드에서 수행된다.
  3. 작업이 완료되면 이벤트 루프가 이를 감지하고, 가용한 스레드에 "결과가 도착했으니 후속 작업(`flatMap` 등)을 실행하라"고 알린다.


* **이점:** 스레드가 멈추지 않고 끊임없이 일(CPU 연산)을 하므로, 적은 수의 스레드(보통 CPU 코어 수 * 2)만으로도 수만 건의 동시 요청을 효율적으로 처리할 수 있다.

---

### 5. Spring WebFlux와 Project Reactor

Spring 생태계에서는 `Spring MVC`와 대비되는 `Spring WebFlux`를 통해 리액티브 프로그래밍을 지원한다.

#### 5.1 기술 스택 비교

| 항목 | Spring MVC | Spring WebFlux |
| --- | --- | --- |
| **기반 기술** | Blocking I/O, Servlet API | Non-Blocking I/O, Netty (기본) |
| **동시성 모델** | Thread per Request | Event Loop |
| **리턴 타입** | `T`, `List<T>` (완성된 데이터) | `Mono<T>`, `Flux<T>` (데이터 흐름의 정의) |
| **적합한 작업** | CPU 집약적 작업, 전통적 CRUD | I/O 집약적 작업, 고트래픽 서비스 |

#### 5.2 Reactor 타입: Mono와 Flux

Spring WebFlux는 `Project Reactor` 라이브러리를 기반으로 하며, 두 가지 주요 데이터 타입을 제공한다.

* **Mono<T>:** 0개 또는 1개의 데이터를 발행하는 스트림. (예: 단일 사용자 조회 `findById`)
* **Flux<T>:** 0개부터 N개(무한대 포함)의 데이터를 발행하는 스트림. (예: 상품 목록 조회, 실시간 로그)

---

### 6. 코드 심층 분석 (명령형 vs 리액티브)

사용자 정보를 조회하고, 해당 사용자의 주문 내역을 가져와 합치는 시나리오를 통해 두 방식의 차이를 분석한다.

#### 6.1 명령형 프로그래밍 (Blocking)

```kotlin
@Service
class UserService(
    private val userRepository: UserRepository,
    private val orderRepository: OrderRepository
) {
    fun getUserWithOrders(userId: String): UserResponse {
        // 1. 사용자 조회 (Blocking): 응답이 올 때까지 여기서 멈춤
        val user = userRepository.findById(userId)
            ?: throw NotFoundException()

        // 2. 주문 내역 조회 (Blocking): 1번이 끝나야 실행됨. 다시 멈춤
        val orders = orderRepository.findByUserId(user.id)

        // 3. 결과 반환
        return UserResponse(user, orders)
    }
}

```

* **실행 시간:** (사용자 조회 시간) + (주문 조회 시간). 순차적 실행이 강제된다.
* **자원:** 각 단계마다 스레드가 점유된 채로 대기한다.

#### 6.2 리액티브 프로그래밍 (Non-Blocking)

```kotlin
@Service
class UserService(
    private val userRepository: ReactiveUserRepository,
    private val webClient: WebClient
) {
    fun getUserWithOrders(userId: String): Mono<UserResponse> {

        // 1. 사용자 조회 스트림 정의 (즉시 실행 X, 정의만 함)
        val userMono = userRepository.findById(userId)

        // 2. 주문 내역 조회 스트림 정의 (외부 API 비동기 호출)
        val ordersMono = webClient.get()
            .uri("/orders?userId={id}", userId)
            .retrieve()
            .bodyToFlux<Order>()
            .collectList()

        // 3. Zip 연산자: 두 개의 비동기 작업을 병렬로 시작하고 결합
        return Mono.zip(userMono, ordersMono)
            .map { (user, orders) ->
                // 두 데이터가 모두 도착했을 때 실행되는 로직
                UserResponse(user, orders)
            }
    }
}

```
* **실행 흐름 상세 분석:**
1. 컨트롤러에서 `userService.getUserWithOrders`를 호출하면, `subscribe()`을 하여 내부 로직이 동작한다.
2. `Mono.zip`이 구독(`subscribe`)되는 순간, `userRepository` 조회와 `webClient` 호출이 **거의 동시에** 비동기로 시작된다.
3메인 스레드는 네트워크 요청만 보내놓고 즉시 반환된다(Non-blocking).
4**병렬 처리 효과:** 두 작업 중 더 오래 걸리는 작업의 시간만큼만 소요된다. (Max(사용자 조회, 주문 조회)).
5두 응답이 모두 도착하면, 대기하던 이벤트가 트리거되어 `map` 연산 내부에서 객체를 생성하고 응답을 보낸다.

---

### 7. 도입 시 고려사항 (장단점)

리액티브 프로그래밍은 강력하지만 '은탄환(Silver Bullet)'은 아니다.

#### 7.1 장점 (Pros)

* **고성능 & 고효율:** 적은 하드웨어 리소스로 더 많은 트래픽을 감당할 수 있다.
* **탄력성 (Resilience):** 에러가 발생해도 시스템 전체로 전파되지 않도록 격리하고 처리하기 용이하다.
* **반응성 (Responsiveness):** 사용자에게 즉각적인 응답을 줄 수 있다.

#### 7.2 단점 및 난관 (Cons)

* **높은 학습 곡선:** 함수형 프로그래밍에 대한 이해가 필수적이며, 사고방식을 완전히 바꿔야 한다.
* **디버깅의 어려움:**
* 코드의 실행 시점과 정의 시점이 다르다.
* 스택 트레이스(Stack Trace)가 여러 스레드를 넘나들며 복잡하게 출력되어, 에러 원인을 추적하기 어렵다.


* **라이브러리 호환성:** JDBC, JPA 등 기존 블로킹 방식의 라이브러리를 섞어 쓰면 리액티브의 장점이 사라진다. (R2DBC 등 전용 라이브러리 필요)

---

### 8. 실무 적용 사례

---

### 9. 요약

리액티브 프로그래밍은 데이터의 흐름과 변화에 반응하는 **비동기 논블로킹 패러다임**이다. 이는 기존 명령형 프로그래밍의 한계인 스레드 블로킹 문제를 해결하여, 현대의 분산 시스템과 고트래픽 환경에서 **시스템의 확장성과 반응성**을 극대화한다.

다만, 코드 복잡도가 높고 디버깅이 어렵기 때문에 단순한 비즈니스 로직보다는 **I/O 작업이 많고 높은 성능이 요구되는 서비스**에 선별적으로 도입하는 전략이 필요하다.

# 목차

1. **메시징 시스템 개요**
   1.1 정의
   1.2 도입 목적 및 이점
   1.3 기본 구성 요소
2. **메시징 시스템의 유형**
   2.1 메시지 큐 (Message Queue)
   2.2 이벤트 스트리밍 (Event Streaming)
   2.3 클라우드 관리형 서비스 (Cloud Managed)
3. **RabbitMQ 상세 분석**
   3.1 개요 및 아키텍처
   3.2 Exchange의 역할과 종류 (상세)
   3.3 Exchange 설정 및 바인딩
   3.4 메시지 수명 관리 프로세스
4. **Apache Kafka 상세 분석**
   4.1 개요 및 아키텍처
   4.2 데이터 처리 단계별 상세 동작
   4.3 물리적 저장 및 데이터 관리 (세그먼트/리텐션)
   4.4 컨슈머와 파티션의 관계 (확장성)
   4.5 데이터 내구성 설정 (Acks 종류)
5. **실무 적용 사례**
6. **요약**

---

> 이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 메시징 시스템 개요

#### 1.1 정의

애플리케이션 간 데이터를 주고받을 때, 시스템을 직접 연결하지 않고 중간에 **‘중개자(Broker)’**를 두어 데이터를 전달하는 소프트웨어 인프라를 의미한다.

#### 1.2 도입 목적 및 이점

* **느슨한 결합 (Decoupling):** 생산자(Producer)와 소비자(Consumer)가 서로의 시스템 상태나 존재를 알 필요가 없다. 새로운 소비자를 추가하거나 제거해도 생산자의 코드를 수정할 필요가 없다.
* **비동기 처리 (Asynchronous Processing):** 무거운 작업을 즉시 처리하지 않고 큐에 넣어둔 뒤 나중에 천천히 처리할 수 있어, 사용자에게 빠른 응답 속도를 제공한다.
* **부하 분산 및 버퍼링 (Throttling):** 트래픽이 폭주할 경우 데이터를 중간 큐에 쌓아두고, 소비자가 처리 가능한 속도로 가져가게 함으로써 시스템 다운을 방지한다.

#### 1.3 기본 구성 요소

* **생산자 (Producer):** 메시지를 생성하여 보내는 주체
* **소비자 (Consumer):** 메시지를 읽어서 비즈니스 로직을 처리하는 주체
* **메시지 브로커 (Message Broker):** 메시지를 중간에서 저장하고 전달하는 서버

---

### 2. 메시징 시스템의 유형

#### 2.1 메시지 큐 (Message Queue)

가장 기본적인 형태로, **‘작업(Task)’**을 처리하는 데 초점이 맞춰져 있다.

* **핵심 컨셉:** 데이터를 안전하게 전달하는 것이 목표이며, 소비자가 데이터를 성공적으로 받으면 큐에서 해당 데이터를 삭제한다. 복잡한 라우팅 규칙 설정에 강점이 있다.
* **대표 구현체:** RabbitMQ, ActiveMQ

#### 2.2 이벤트 스트리밍 (Event Streaming)

**‘데이터의 흐름(Flow) 및 저장’**과 분석에 초점이 맞춰져 있다.

* **핵심 컨셉:** 데이터를 소비해도 지우지 않고 파일 시스템처럼 보존한다. 실시간 로그 수집이나 대용량 데이터 처리에 압도적인 성능을 보인다.
* **대표 구현체:** Apache Kafka, Apache Pulsar

#### 2.3 클라우드 관리형 서비스 (Cloud Managed)

서버 설치 없이 AWS, Google Cloud 등에서 API처럼 비용을 지불하고 사용하는 서비스다.

* **핵심 컨셉:** 설치 및 운영 부담이 없으며 무한 확장이 가능하다는 편리함이 있다. 단, 사용량에 따른 비용이 발생한다.
* **대표 구현체:** Amazon SQS, Amazon Kinesis

---

### 3. RabbitMQ 상세 분석

#### 3.1 개요 및 아키텍처

데이터(메시지)를 받아 적절한 목적지로 배달해주는 **메시지 브로커** 역할에 충실하다.

* **표준 프로토콜:** AMQP(Advanced Message Queuing Protocol)라는 국제 표준을 구현하여 체계적이며 다양한 언어와 쉽게 호환된다.
* **스마트 브로커:** 메시지를 누구에게 줄지, 전달 실패 시 어떻게 할지 등을 브로커가 주도적으로 관리한다.
* **데이터 흐름:**
1. **Producer (생산자):** 큐에 직접 메시지를 보내지 않고, 오직 **Exchange**에만 보낸다.
2. **Exchange (교환기):** 생산자에게 받은 메시지를 어떤 큐로 보낼지 결정하는 라우터다.
3. **Queue (큐):** 메시지가 쌓이는 버퍼로, 소비자가 가져가기 전까지 보관된다.
4. **Consumer (소비자):** 큐에서 메시지를 꺼내 처리한다.



#### 3.2 Exchange의 역할과 종류 (상세)

Exchange는 **"유연한 라우팅"**을 담당한다. 생산자는 "누가 받을지" 신경 쓰지 않고 메시지를 던지면, Exchange가 설정된 규칙(1:1, 1:N, 조건부 배달 등)에 따라 배달한다.

**1) Direct Exchange**

* **특징:** "정확한 주소로만 배달한다."
* **동작:** 생산자가 보낸 라우팅 키와 큐가 연결될 때 설정한 키가 **100% 일치**해야 전달된다.
* **예시:**
* Exchange가 라우팅 키 `kong`으로 메시지를 받음.
* Queue A (`kong`으로 연결됨) → **전달 O**
* Queue B (`black`으로 연결됨) → **전달 X**



**2) Fanout Exchange**

* **특징:** "묻지도 따지지도 않고 모두에게 복사해 준다."
* **동작:** 라우팅 키를 완전히 무시하고, 이 Exchange에 연결된 **모든 큐**에 메시지를 복사해서 뿌린다.
* **예시:** Queue A, Queue B, Queue C 모두에게 똑같은 메시지가 전달된다.

**3) Topic Exchange**

* **특징:** "패턴이 맞는 곳으로 배달한다."
* **패턴 문자:**
* `*`: 정확히 한 단어를 대체
* `#`: 0개 이상의 여러 단어를 대체


* **예시 동작:** (생산자가 `usa.news.weather` 키로 전송 시)
* Queue A (`usa.#`): 'usa로 시작하는 모든 것' 수신 → **전달 O**
* Queue B (`*.news.*`): '가운데가 news인 세 단어' 수신 → **전달 O**
* Queue C (`korea.news`): 'korea.news'만 수신 → **전달 X**



#### 3.3 Exchange 설정 및 바인딩

* **보낼 때 (Producer):** 메시지에 라우팅 키를 포함한다. (예: `error` 키 부착)
* **연결할 때 (Binding):** Exchange와 큐를 연결하는 규칙을 설정한다. (예: 이 큐는 `error` 키만 받음)
* **결과:** Exchange가 두 키를 비교하여 일치할 경우 큐에 넣어준다.

#### 3.4 메시지 수명 관리 (Ack & Delete)

1. **전달:** 브로커가 컨슈머에게 메시지를 준다.
2. **Ack (확인 응답):** 컨슈머가 처리를 완료하면 브로커에게 "Ack" 신호를 보낸다.
3. **삭제:** 브로커가 Ack를 받으면 그제서야 큐에서 메시지를 **영구 삭제**한다.
* 만약 Ack가 오지 않으면 컨슈머 장애로 판단하고 다른 컨슈머에게 재전송한다.



---

### 4. Apache Kafka 상세 분석

#### 4.1 개요 및 아키텍처

단순 큐가 아니라, 이벤트 데이터(로그)를 지속적으로 저장하고 처리하는 **플랫폼**이다. RabbitMQ가 '처리 후 삭제'라면, Kafka는 '처리 후에도 보관'하여 과거의 기록을 유지한다.

* **토픽 (Topic):** 데이터를 구분하는 주제. (순서 보장 X)
* **파티션 (Partition):** 토픽을 물리적으로 쪼갠 단위이자 순서가 보장되는 최소 단위. 병렬 처리의 핵심이다.
* **오프셋 (Offset):** 파티션 안에서 메시지의 위치 번호. 컨슈머가 어디까지 읽었는지 직접 관리한다.
* **컨슈머 그룹:** 같은 목적을 가진 컨슈머들의 묶음이다.

#### 4.2 데이터 처리 단계별 상세 동작

**1단계: 쓰기 (Producer → Broker)**

* **키가 없는 경우 (Round-Robin):** 데이터를 파티션 0, 1, 2... 순으로 공평하게 분배한다.
* **키가 있는 경우 (Hash):** 특정 키(예: 주문번호)의 해시값을 통해 항상 동일한 파티션으로 보낸다. (순서 보장 목적)

**2단계: 저장 (Broker 내부)**

* **순차적 추가 (Append-only):** 중간 수정 없이 오직 맨 뒤에 이어 붙이기만 하므로 디스크 쓰기 속도가 매우 빠르다.
* **복제:** 서버 장애 시 데이터 유실을 막기 위해 데이터를 다른 브로커에 복제해 둔다.

**3단계: 읽기 (Broker → Consumer)**

* **폴링 (Polling):** 브로커가 주는 것이 아니라, 컨슈머가 자신의 속도에 맞춰 "다음 데이터 주세요"라고 요청한다.
* **오프셋 커밋:** 처리가 끝나면 `__consumer_offsets`라는 특수 토픽에 "여기까지 읽음"을 기록한다. 이를 통해 재부팅 되어도 작업을 이어서 할 수 있다.

#### 4.3 물리적 저장 및 데이터 관리 (세그먼트/리텐션)

**1) 물리적 저장 방식: 세그먼트**
Kafka는 파티션을 **세그먼트**라는 작은 파일 조각들로 나눠 저장한다.

* **활성 세그먼트:** 현재 데이터가 쓰이고 있는 파일.
* **닫힌 세그먼트:** 용량이 차거나 시간이 지나 읽기 전용으로 전환된 파일.

**2) 데이터 보관(Retention) 및 삭제 정책**

* **보관 기준:** 시간(N시간 경과) 또는 용량(파티션 크기 N GB 초과) 기준을 적용한다.
* **삭제 정책:**
* **삭제 (Delete):** 기준이 지난 세그먼트를 통째로 삭제한다. (기본값)
* **압축 (Compact):** 동일한 키에 대해 최신 데이터만 남기고 이전 데이터는 제거한다.



**3) 메시지 구성 요소**
메시지는 `Key` (파티션 결정), `Value` (실제 데이터), `Timestamp`, `Headers`, `Offset` 등을 포함한다.

**4) 메시지를 저장하는 이유**

* **장애 복구:** 컨슈머 오프셋만 과거로 돌리면 해당 지점부터 재처리(Replay)가 가능하다.
* **속도 차이 해결:** 생산 폭주 시 Kafka에 저장해두고, 컨슈머는 감당 가능한 속도로 처리한다.
* **이벤트 소싱:** 현재 상태뿐만 아니라 데이터의 모든 변화 과정을 저장하여, 언제든 과거 상태를 추적하거나 재현할 수 있다.

#### 4.4 컨슈머와 파티션의 관계 (확장성)

> **절대 규칙:** 하나의 파티션은 동일 컨슈머 그룹 내에서 **오직 하나의 컨슈머**만 연결된다.

1. **파티션 수 > 컨슈머 수:** 한 컨슈머가 여러 파티션을 처리하므로 부하가 심해질 수 있다.
2. **파티션 수 = 컨슈머 수:** 가장 이상적인 1:1 병렬 처리 구조다.
3. **파티션 수 < 컨슈머 수:** 남는 컨슈머는 일을 하지 않고 쉰다(유휴 상태). 이는 자원 낭비이므로, Scale-out 시 파티션 개수도 함께 늘려야 한다.

* **왜 여러 컨슈머가 한 파티션을 못 읽나?**
* 순서 보장 때문이다. 여러 컨슈머가 동시에 읽어가면 메시지 처리 순서가 뒤섞일 수 있다.



#### 4.5 데이터 내구성 설정 (Acks 종류)

프로듀서가 메시지를 보낼 때, 브로커로부터 받는 확인 응답(Ack) 수준을 설정하여 **속도와 안정성 간의 트레이드오프**를 결정한다.

1. **acks=0 (No Ack):** 보내고 확인하지 않음. 속도는 가장 빠르나 유실 가능성이 높다.
2. **acks=1:** 리더 파티션 저장만 확인. 적당한 속도와 안정성을 가진다. (단, 리더 장애 시 유실 가능)
3. **acks=all(-1):** 모든 팔로워(복제본) 저장까지 확인. 속도는 가장 느리지만 데이터 유실 가능성이 거의 없다.

---

### 5. 실무 적용 사례

---

### 6. 요약

메시징 시스템은 시스템 간 결합도를 낮추고 비동기 처리를 통해 안정성을 확보하는 필수 인프라다.
**RabbitMQ**는 복잡한 라우팅과 즉각적인 작업 처리가 필요한 서비스에 적합하며, **Kafka**는 대용량 데이터의 실시간 처리, 저장, 그리고 장애 복구가 중요한 파이프라인 구축에 강력한 성능을 발휘한다. 개발자는 각 시스템의 특성(삭제 vs 보관, 라우팅 vs 스트리밍)을 이해하고 목적에 맞게 선택해야 한다.
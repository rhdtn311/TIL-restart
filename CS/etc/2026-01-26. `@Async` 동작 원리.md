# 목차

1. @Async란 무엇이고 왜 사용하는가?
2. 핵심 동작 원리: AOP와 프록시(Proxy)
3. 실행 주체: 스레드 풀(Thread Pool) 설정
4. 반환 타입별 특징과 활용
5. 주요 주의사항
6. 실무 적용 사례
7. 요약

---

이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. @Async란 무엇이고 왜 사용하는가?

`@Async`는 특정 메서드를 현재 실행 흐름(Main Thread)이 아닌 **별도의 스레드에서 비동기적으로 실행**하도록 지원하는 Spring 어노테이션이다.

* **사용 목적:** 주된 목적은 사용자 요청에 대한 **응답 속도 향상**이다.
* **활용 예시:** 회원가입 요청 시 '환영 이메일 발송'과 같이 시간이 소요되는 작업을 비동기로 처리하면, 서버는 이메일 발송 완료를 기다리지 않고 즉시 "회원가입 완료" 응답을 반환할 수 있다. 이는 사용자 경험(UX)을 크게 개선한다.

---

### 2. 핵심 동작 원리: AOP와 프록시(Proxy)

`@Async`는 Spring의 핵심 기술인 **AOP(관점 지향 프로그래밍)**와 **프록시(Proxy)** 패턴을 기반으로 동작한다.

#### 2.1 AOP (Aspect-Oriented Programming)

AOP는 로깅, 보안, 트랜잭션 등 여러 모듈에 공통적으로 나타나는 기능(Cross-Cutting Concerns)을 핵심 비즈니스 로직에서 분리하는 기술이다. `@Async`에서는 **'메서드를 별도 스레드에서 실행하는 행위'** 자체가 공통 관심사로 처리된다.

#### 2.2 프록시(Proxy) 동작 과정

프록시는 원본 객체를 감싸는 **'대리인 객체'**다. Spring AOP는 원본 Bean 대신 프록시 Bean을 생성하여 비동기 로직을 수행한다.

1. **프록시 생성:** Spring 컨테이너는 `@Async`가 선언된 메서드를 포함한 Bean의 프록시 객체를 생성한다.
2. **요청 가로채기:** 외부에서 해당 메서드를 호출하면, 실제로는 프록시 객체가 호출을 가로챈다(Intercept).
3. **비동기 위임:** 프록시는 원본 메서드를 직접 실행하지 않고, **별도의 스레드(TaskExecutor)**에 실행을 위임한다.
4. **제어권 반환:** 호출한 쪽(Main Thread)에는 즉시 제어권을 반환하여 다음 로직을 수행하게 한다.

---

### 3. 실행 주체: 스레드 풀(Thread Pool) 설정

`@Async` 작업은 **스레드 풀**에서 관리되는 스레드에 의해 실행된다. 별도의 설정이 없으면 Spring은 `SimpleAsyncTaskExecutor`를 사용하는데, 이는 매 요청마다 새로운 스레드를 생성하므로 리소스 낭비가 심하다. 따라서 운영 환경에서는 반드시 **커스텀 스레드 풀(`ThreadPoolTaskExecutor`)**을 설정해야 한다.

#### 설정 예시 (`@Configuration`)

```kotlin
@Configuration
@EnableAsync
class AsyncConfig {

    @Bean(name = ["myAsyncTaskExecutor"])
    fun taskExecutor(): Executor {
        val executor = ThreadPoolTaskExecutor()
        executor.corePoolSize = 5       // 기본 스레드 수
        executor.maxPoolSize = 10       // 최대 스레드 수
        executor.queueCapacity = 25     // 대기 큐 크기
        executor.setThreadNamePrefix("my-async-")
        executor.initialize()
        return executor
    }
}

```

---

### 4. 반환 타입별 특징과 활용

`@Async` 메서드는 작업의 성격에 따라 `void`, `Future`, `CompletableFuture` 중 적절한 반환 타입을 선택해야 한다.

#### 4.1 `void` (Fire-and-Forget)

비동기 작업의 결과값이나 성공 여부에 관심이 없을 때 사용한다.

* **특징:** 호출자는 메서드 실행 후 즉시 리턴받으며, 작업의 완료 여부를 확인하지 않는다.
* **주의사항:** 메서드 내부에서 발생한 예외가 호출자에게 전파되지 않으므로, 별도의 예외 처리 전략이 필요하다.

```kotlin
// Controller
@GetMapping(value = ["/test-kong"])
fun asyncTest(): String {
    println("before evaluationService.asyncTest")
    for (i in 1..3) {
        evaluationService.asyncTest(i)
    }
    println("after evaluationService.asyncTest")
    return "asyncTest"
}

// Service
@Async
fun asyncTest(i: Int) {
    Thread.sleep(1000)
    println("async service ${i}가 실행됩니다.")
}

```

#### 4.2 `Future<T>`

비동기 작업의 결과를 언젠가는 받아야 할 때 사용한다.

* **특징:** `future.get()`을 호출하는 시점에 작업이 완료될 때까지 **블로킹(Blocking)** 상태가 된다.
* **단점:** 비동기의 이점을 살리기 위해선 `get()` 호출 시점을 잘 조절해야 하며, 복잡한 비동기 흐름 제어에는 한계가 있다.

```kotlin
// Controller
@GetMapping(value = ["/test-kong"])
fun asyncTest(): String {
    println("before evaluationService.asyncTest")
    for (i in 1..3) {
        val result = evaluationService.asyncTest(i)
        // 여기서 블로킹 발생
        println("result.get() = ${result.get()}")
    }
    println("after evaluationService.asyncTest")
    return "asyncTest"
}

// Service
@Async
fun asyncTest(i: Int): Future<Int> {
    Thread.sleep(1000)
    println("async service ${i}가 실행됩니다.")
    return AsyncResult.forValue<Int>(i)
}

```

#### 4.3 `CompletableFuture<T>`

가장 권장되는 방식이다. 비동기 작업 결과를 받아 논블로킹(Non-blocking) 방식으로 후속 작업을 연결하거나, 여러 작업을 조합할 수 있다.

* **장점:**
* **메서드 체이닝:** `thenApply`, `thenAccept` 등을 통해 콜백 지옥 없이 코드를 작성할 수 있다.
* **예외 처리:** `exceptionally`를 통해 우아한 예외 처리가 가능하다.
* **작업 조합:** `allOf` 등을 사용하여 병렬 작업을 손쉽게 제어할 수 있다.



```kotlin
// Controller
@GetMapping("/test-kong-completable")
fun asyncTestCompletable(): String {
    println("before evaluationService.asyncTestCompletable")

    val futures = (1..3).map { i ->
        evaluationService.asyncTest(i)
            .thenApply { value ->
                println("success result = $value")
                value
            }
            .exceptionally { ex ->
                println("error = ${ex.message}")
                null
            }
    }

    // 모든 작업이 끝날 때까지 대기 (필요한 경우)
    CompletableFuture.allOf(*futures.toTypedArray()).join()

    println("after evaluationService.asyncTestCompletable")
    return "asyncTestCompletable"
}

// Service
@Async
fun asyncTest(i: Int): CompletableFuture<Int> {
    Thread.sleep(1000)
    println("async service (CompletableFuture) $i 실행됩니다.")
    return CompletableFuture.completedFuture(i)
}

```

---

### 5. 주요 주의사항

`@Async` 사용 시 다음 사항들을 간과하면 기능이 정상 동작하지 않거나 예기치 않은 오류가 발생할 수 있다.

1. **자가 호출(Self-Invocation) 불가:**
* 같은 클래스 내부에서 `this.method()` 형태로 `@Async` 메서드를 호출하면 프록시를 거치지 않으므로 **비동기 처리가 되지 않는다**. 반드시 다른 Bean에서 주입받아 호출해야 한다.


2. **접근 제어자 제한:**
* 프록시 객체가 원본 메서드를 오버라이딩하거나 위임해야 하므로, **`private` 메서드에는 적용할 수 없다**. 반드시 `public` 메서드여야 한다.


3. **예외 처리:**
* `void` 반환 타입의 메서드에서 예외가 발생하면 호출 스레드에서는 이를 알 수 없다. 전역적인 에러 핸들링을 위해 `AsyncUncaughtExceptionHandler`를 구현하여 등록하는 것이 좋다.


4. **트랜잭션 분리:**
* `@Async` 메서드는 새로운 스레드에서 실행되므로, **기존 트랜잭션 컨텍스트가 전파되지 않는다**. 비동기 메서드 내에서 DB 작업이 필요하다면 `@Transactional`을 별도로 선언해야 한다.



---

### 실무 적용 사례
---

### 7. 요약

`@Async`는 Spring AOP와 프록시 패턴을 이용해 메서드를 별도 스레드에서 비동기적으로 실행하는 강력한 도구다. 이를 효과적으로 사용하기 위해서는 **적절한 스레드 풀 설정**이 필수적이며, 작업의 성격에 따라 `void`나 `CompletableFuture` 등의 반환 타입을 올바르게 선택해야 한다. 또한 **자가 호출 금지**와 같은 프록시 기반의 제약 사항을 명확히 이해하고 사용해야 의도한 대로 성능 개선 효과를 얻을 수 있다.
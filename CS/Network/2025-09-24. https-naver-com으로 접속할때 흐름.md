이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했습니다.

### 1. IP 주소 확인: DNS 질의 과정
> **DNS(Domain Name System)** 질의는 사용자가 요청한 도메인 이름에 해당하는 실제 서버의 **IP 주소**를 찾는 핵심적인 절차다.

* **로컬 캐시 조회**: 가장 먼저 브라우저와 운영체제(OS)의 **로컬 캐시**에 해당 도메인의 IP 주소 기록이 있는지 확인한다.
* **ISP DNS 서버 질의**: 캐시에 정보가 없으면, 인터넷 서비스 제공업체(**ISP**)가 관리하는 DNS 서버에 질의한다.
* **루트 DNS 서버 질의**: ISP DNS 서버에도 정보가 없다면, 전 세계 DNS 시스템의 최상위 계층인 **루트 DNS 서버** 중 하나에 질의한다. 루트 서버는 `.com`과 같은 최상위 도메인(**TLD**)을 관리하는 서버의 주소를 알려준다.
* **TLD DNS 서버 질의**: ISP DNS 서버는 루트 서버로부터 전달받은 **TLD 서버** 주소로 다시 질의한다. TLD 서버는 `naver.com`과 같이 특정 도메인을 관리하는 최종 DNS 서버의 주소를 응답한다.
* **최종 DNS 서버 질의**: 마지막으로, ISP DNS 서버는 `naver.com`을 직접 관리하는 DNS 서버에 질의하여 최종적으로 도메인의 IP 주소를 응답받는다.

> 이 과정을 통해 클라이언트는 `naver.com` 서버와 통신하기 위한 IP 주소를 확보한다.

---

### 2. 네트워크 통신 채널 구축
> IP 주소를 확보한 후, 데이터를 안전하고 안정적으로 주고받기 위한 통신 채널을 수립한다.

#### 2.1. TCP 3-Way Handshake: 연결 수립
**TCP 3-Way Handshake**는 클라이언트와 서버 간의 신뢰성 있는 양방향 통신 연결을 설정하는 과정이다.

* **1단계 (SYN)**: 클라이언트는 서버에 접속을 요청하기 위해 **SYN(Synchronize)** 플래그가 설정된 TCP 패킷을 전송한다. 이 패킷에는 데이터 순서 식별을 위한 임의의 초기 순차 번호가 포함된다.
* **2단계 (SYN+ACK)**: 서버는 클라이언트의 요청을 수락한다는 의미의 **ACK(Acknowledge)** 플래그와, 서버 역시 통신을 시작할 준비가 되었음을 알리는 **SYN** 플래그를 함께 설정하여 응답한다.
* **3단계 (ACK)**: 클라이언트는 서버의 응답을 잘 받았다는 **ACK** 패킷을 전송한다. 이로써 통신을 위한 연결이 최종적으로 확립된다.

> 이 3단계 과정을 통해 데이터 손실 없이 안정적으로 정보를 교환할 수 있는 TCP 연결이 수립된다.

#### 2.2. TLS/SSL Handshake: 데이터 암호화
**TLS/SSL Handshake**는 HTTPS 통신에서 주고받는 데이터를 암호화하여 제3자가 내용을 가로채도 해독할 수 없도록 보안을 확보하는 절차다.

* **Client Hello**: 클라이언트(브라우저)가 서버에 지원 가능한 암호화 방식 목록과 임의의 데이터를 전송한다.
* **Server Hello**: 서버는 클라이언트가 보낸 목록에서 하나의 암호화 방식을 선택하고, 자신의 신원을 증명하는 **SSL 인증서**와 또 다른 임의의 데이터를 클라이언트에 전송한다.
* **인증서 검증**: 클라이언트는 서버로부터 받은 SSL 인증서가 신뢰할 수 있는 인증 기관(CA)에서 발급되었는지, 유효 기간이 만료되지 않았는지 등을 검증한다.
* **키 교환**: 클라이언트는 암호화에 사용할 임시 비밀 정보(Premaster Secret)를 생성한다. 이 정보를 서버의 SSL 인증서에 포함된 **공개키**로 암호화하여 서버에 전송한다. 이 암호화된 정보는 오직 서버만이 가진 **개인키**로만 복호화할 수 있다. (**비대칭 암호화**)
* **세션 키 생성**: 클라이언트와 서버는 각자 교환한 임의의 데이터와 임시 비밀 정보를 조합하여, 실제 데이터를 암호화하고 복호화하는 데 사용할 **세션 키**를 생성한다. 이 키는 대칭키이며 해당 세션에서만 사용된다.
* **핸드셰이크 완료**: 양측은 생성된 세션 키로 암호화된 `Finished` 메시지를 교환하며, 암호화 채널이 성공적으로 구축되었음을 확인한다.

> 이 절차를 통해 클라이언트와 서버 간의 모든 통신 내용을 보호하는 안전한 비밀 통신 터널이 완성된다.

---

### 3. 인프라 계층: 서버 시스템 요청 전달
> 암호화된 통신 채널을 통해 생성된 HTTP 요청이 서버 인프라로 전달된다.

#### 3.1. HTTP 요청 생성 및 전송
브라우저는 다음과 같은 주요 정보를 포함하는 **HTTP 요청 메시지**를 생성하여 서버로 전송한다.
* HTTP 메서드 및 버전 (`GET / HTTP/1.1`)
* `Host`: 요청 대상 서버의 도메인 주소
* `User-Agent`: 브라우저 및 운영체제 정보
* `Accept`: 수신 가능한 콘텐츠 타입
* `Cookie`: 사용자 인증 정보 등

#### 3.2. 방화벽 및 L4 로드밸런서
* **방화벽**: 서버 시스템의 가장 앞단에서 허용된 트래픽만 통과시키는 보안 장비다. 일반적으로 HTTPS 통신을 위한 **443번 포트**와 같이 사전에 정의된 규칙에 부합하는 요청만 허용한다.
* **L4 로드밸런서**: 방화벽을 통과한 트래픽을 여러 대의 백엔드 웹 서버로 분산시키는 역할을 한다. TCP/IP 헤더 정보를 기반으로 설정된 분산 알고리즘에 따라 가장 부하가 적은 서버에 요청을 전달한다.

#### 3.3. Nginx: 리버스 프록시
**Nginx**와 같은 리버스 프록시 서버는 클라이언트 요청을 내부 서버로 전달하는 중간 다리 역할을 수행한다.
* **SSL/TLS 종료(Termination)**: 클라이언트와 맺었던 암호화 통신을 이곳에서 종료한다. Nginx가 자신의 개인키로 요청을 복호화하고, 내부망의 웹 서버와는 암호화되지 않은 일반 HTTP로 통신하여 내부 시스템의 부하를 줄인다.
* **콘텐츠 라우팅**: 요청이 정적 콘텐츠(HTML, CSS, 이미지 등)를 요구하면 Nginx가 직접 처리하여 반환하고, 동적 콘텐츠(사용자 맞춤형 데이터 등)를 요구하면 애플리케이션 서버(WAS)로 요청을 전달한다.

---

### 4. 애플리케이션 계층: Spring Boot 요청 처리
> 복호화된 HTTP 요청이 최종적으로 Spring Boot 애플리케이션에 도달하여 처리된다.

#### 4.1. 내장 Tomcat의 요청 수신
* 내장된 **Tomcat** 서버의 **Connector** 컴포넌트가 TCP 연결을 수락하고, 스레드 풀에서 작업 스레드를 할당받아 요청을 처리한다.
* **서블릿 컨테이너**는 수신한 HTTP 메시지를 파싱하여, Spring 애플리케이션이 이해할 수 있는 `HttpServletRequest` 객체를 생성한다.

#### 4.2. 필터 및 DispatcherServlet 처리 과정
* **필터(Filter)**: `DispatcherServlet`에 도달하기 전에 공통적으로 필요한 로직(인코딩, 보안 등)을 처리한다.
* **DispatcherServlet**: Spring MVC의 핵심 컨트롤 타워로서, 요청 처리의 전 과정을 지휘한다.
    1.  **HandlerMapping**: 요청 URL과 HTTP 메서드를 분석하여 어떤 컨트롤러 메서드가 이 요청을 처리해야 할지 결정한다.
    2.  **스프링 인터셉터**: 핸들러(컨트롤러) 실행 전후에 특정 로직을 수행한다.
    3.  **HandlerAdapter**: 결정된 핸들러를 실제로 실행하는 역할을 한다. `@RequestParam`, `@RequestBody` 등의 어노테이션을 해석하여 메서드 인자를 준비하고 데이터 바인딩 및 유효성 검사를 수행한다.
    4.  **핸들러 실행**: 준비된 인자와 함께 컨트롤러 메서드를 호출하여 핵심 비즈니스 로직을 수행한다.
    5.  **HTTP 응답 생성**: 핸들러가 DTO와 같은 객체를 반환하면, **HttpMessageConverter**(주로 `MappingJackson2HttpMessageConverter`)가 이를 JSON과 같은 형식의 HTTP 응답 본문으로 변환한다.

> 생성된 HTTP 응답은 지금까지 거쳐온 과정을 역순으로 다시 통과하여 최종적으로 사용자의 브라우저에 전달된다.

### 요약
사용자가 브라우저에 도메인을 입력하면, **DNS 질의**를 통해 서버의 IP 주소를 찾고 **TCP 및 TLS Handshake**를 통해 안전한 통신 채널을 구축한다. 이후 생성된 HTTP 요청은 **방화벽**, **로드밸런서**, **리버스 프록시**와 같은 인프라 계층을 거쳐 최종적으로 **Spring Boot 애플리케이션**에 도달한다. 애플리케이션 내에서는 **DispatcherServlet**을 중심으로 요청이 처리되고, 그 결과가 응답으로 생성되어 사용자에게 반환된다.
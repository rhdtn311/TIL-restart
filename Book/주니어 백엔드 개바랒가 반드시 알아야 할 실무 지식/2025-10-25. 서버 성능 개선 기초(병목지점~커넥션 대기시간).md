### 목차

* 1. 성능 핵심 지표
    * 1.1. 응답 시간 (Response Time)
    * 1.2. 처리량 (Throughput)
* 2. 병목 지점 (Bottleneck) 분석
* 3. 성능 개선 전략
    * 3.1. 수직 확장(Scale-Up)과 수평 확장(Scale-Out)
    * 3.2. DB 커넥션 풀 (Connection Pool)
* 4. 실무 적용 사례
* 5. 요약

---

> 이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 성능 핵심 지표

#### 1.1. 응답 시간 (Response Time)

클라이언트가 서버로 요청을 보내는 과정은 크게 서버 연결과 데이터 전송 두 단계로 나뉜다.
* **서버 연결:** TCP 등을 이용해 서버에 연결한다.
* **데이터 전송:** HTTP POST 방식, JSON 형식 등 정해진 규칙에 따라 데이터를 서버에 전송한다.

**응답 시간**은 주로 다음 두 가지 기준으로 측정한다.
* **TTFB (Time To First Byte):** 응답 데이터의 첫 번째 바이트가 도착할 때까지 걸린 시간
* **TTLB (Time To Last Byte):** 응답 데이터의 마지막 바이트가 도착할 때까지 걸린 시간

응답 시간은 보통 밀리초(ms, 1000ms = 1초) 단위를 사용한다. 전체 응답 시간은 API 요청 전송 시간, 서버 처리 시간, API 응답 전송 시간으로 구성된다.

서버 개발자는 이 중 **서버 처리 시간**을 주로 확인하며, 이는 다음 요소들을 포함한다.
* 로직 수행
* DB 연동
* 외부 API 연동
* 응답 데이터 생성

일반적으로 **DB 연동**과 **외부 API 연동**이 서버 처리 시간에서 가장 큰 비중을 차지하는 경우가 많다.

#### 1.2. 처리량 (Throughput)

**처리량(Throughput)**은 단위 시간당 시스템이 처리하는 작업량을 의미한다. 이를 나타내는 주요 단위는 다음과 같다.
* **TPS (Transaction Per Second):** 초당 트랜잭션 수
* **RPS (Request Per Second):** 초당 요청 수

예를 들어, '상품 주문하기'라는 하나의 트랜잭션이 4개의 개별 API 요청(장바구니 확인, 결제 승인, 주문 생성, 메일 발송)으로 구성될 수 있다. 이 경우, '상품 주문' 완료(트랜잭션)는 1건이므로 **TPS는 1**이지만, 서버가 처리한 총요청 수는 4건이므로 **RPS는 4**가 된다.

| **구분** | **RPS (Requests Per Second)** | **TPS (Transactions Per Second)** |
| --- | --- | --- |
| **의미** | 초당 **요청** 수 | 초당 **트랜잭션(작업 단위)** 수 |
| **측정 대상** | 시스템이 받아들일 수 있는 요청 횟수 | 시스템이 완료할 수 있는 비즈니스 작업 수 |
| **범위** | 비교적 단순한 단위 (예: HTTP 요청) | 더 크고 복잡한 작업의 단위 (예: 결제, 이체) |
| **관계** | 1개의 트랜잭션은 **여러 개의 요청(RPS)**으로 구성될 수 있음 | 1개의 트랜잭션(TPS)이 완료되려면 **여러 개의 요청**이 필요할 수 있음 |

응답 시간 증가는 사용자 이탈로 이어질 수 있으므로, 다음 두 가지 방안을 고려해 대기 시간을 줄여야 한다.
1.  서버가 동시에 처리할 수 있는 요청 수 증가
2.  처리 시간 자체의 단축

효과적인 성능 개선을 위해서는 현재 트래픽이 많은 시간대의 **TPS와 응답 시간**을 측정하고, 이를 바탕으로 목표치를 설정해야 한다. 모니터링 툴을 사용하면 TPS를 빠르고 정확하게 측정할 수 있다.

---

### 2. 병목 지점 (Bottleneck) 분석

서비스 운영 중 트래픽이 증가하고 데이터가 쌓이면서 응답 시간이 느려지는 현상이 발생할 수 있다. 성능 문제는 주로 시스템이 수용 가능한 최대 TPS를 초과하는 트래픽이 유입될 때 발생한다.

TPS를 높이기 위해서는 먼저 성능 문제가 발생하는 지점, 즉 **병목 지점**을 찾아야 한다. 병목 지점은 처리 시간이 오래 걸리는 작업을 식별함으로써 찾을 수 있으며, 일반적으로 DB 작업이나 외부 API 연동 지점에서 발생할 확률이 높다.

---

### 3. 성능 개선 전략

#### 3.1. 수직 확장(Scale-Up)과 수평 확장(Scale-Out)

성능 문제를 해결하는 가장 즉각적인 방법은 확장(Scaling)이며, 두 가지 방식이 있다.
* **수직 확장 (Scale-Up):** 기존 서버의 CPU, 메모리, 디스크 등 자원 성능을 향상시키는 방식이다. 즉각적인 효과를 볼 수 있으나, 비용이 많이 들고 확장에 한계가 있다.
* **수평 확장 (Scale-Out):** 서버를 추가로 투입해 성능을 향상시키는 방식이다.

> **주의:** TPS를 높이기 위해 무작정 서버를 추가(수평 확장)해서는 안 된다. 실제 병목 지점을 파악하는 것이 중요하다. 예를 들어, 병목 지점이 DB에 있는데 애플리케이션 서버만 추가하면 오히려 DB 부하를 가중시켜 더 큰 성능 문제를 야기할 수 있다.

#### 3.2. DB 커넥션 풀 (Connection Pool)

DB를 사용하기 위해서는 '연결 → 쿼리 실행 → 연결 종료'의 3단계를 거치며, 이 과정에서 네트워크 연결 생성 및 종료에 상당한 시간이 소요된다.

**DB 커넥션 풀(Connection Pool)**은 이러한 오버헤드를 줄이기 위해 사용된다. 이는 DB와 미리 연결된 커넥션들을 생성해 '풀(Pool)'에 보관하는 기법이다. 애플리케이션은 DB 작업 필요 시 풀에서 커넥션을 가져와 사용하고, 작업이 끝나면 풀에 다시 반환한다. 이를 통해 커넥션을 재사용하여 응답 시간을 단축시킨다.

커넥션 풀의 주요 설정은 다음과 같다.
* 커넥션 풀 크기
* 풀에 커넥션이 없을 때 대기 시간
* 커넥션 유지 시간

#### 3.2.1. 커넥션 풀 크기 설정

커넥션 풀 크기는 성능에 매우 중요한 영향을 미친다. 예를 들어, 풀 크기가 5이고 개별 쿼리 실행에 1초가 걸린다면, 6개의 요청이 동시에 들어올 경우 마지막 1개 요청은 커넥션이 반환될 때까지 1초를 추가로 대기해야 한다.

풀 크기는 목표 TPS와 전체 응답 시간을 고려하여 설정해야 한다. 쿼리 실행 시간이 0.5초일 때, 풀 크기가 5이면 1초에 10개의 요청(TPS 10)을 처리한다. 동시 요청이 50개 유입되면 모든 요청 처리에 5초가 걸리지만, 풀 크기를 50개로 늘리면 0.5초 만에 모든 요청을 처리할 수 있다.

커넥션 풀은 최소 및 최대 크기를 지정할 수 있으며, 트래픽에 따라 커넥션 수를 조절한다. 만약 트래픽이 순간적으로 급증하는 패턴이라면, DB 연결 시간을 줄이기 위해 최소 크기를 최대 크기와 동일하게 맞추는 것이 좋다.

> **주의:** 병목 지점이 DB 자체에 있다면, 커넥션 풀 크기만 늘리는 것은 오히려 DB 부하를 심화시켜 전체 성능을 저하시킬 수 있다. 이는 애플리케이션의 수평 확장 시에도 동일하게 고려해야 한다.

#### 3.2.2. 커넥션 대기 시간

**커넥션 대기 시간**은 풀에 사용 가능한 커넥션이 없을 때, 요청이 대기할 수 있는 최대 시간이다. 이 시간을 초과하면 오류가 발생한다.

응답 시간이 중요한 서비스일수록 이 시간을 짧게 설정(일반적으로 0.5초~3초)하는 것이 좋다. 대기 시간을 짧게 설정하면 서버 부하 증가를 방지하는 효과도 있다. 예를 들어, 대기 시간이 30초일 때 사용자가 10초 만에 재요청하면, 기존 요청과 신규 요청이 모두 커넥션을 대기하며 서버 부하를 가중시킬 수 있다.

---

### 4. 실무 적용 사례

(추후 실무 적용 시 업데이트 예정)

---

### 5. 요약

시스템 성능은 **응답 시간**과 **처리량(TPS, RPS)**으로 측정하며, 트래픽 증가는 **병목 지점**의 성능 저하를 유발한다. 성능 개선을 위해 **수직/수평 확장**을 고려할 수 있으나, 근본적인 병목 지점 파악이 선행되어야 한다. 특히 DB 연동 부하를 줄이기 위한 **DB 커넥션 풀**의 크기와 대기 시간 설정은 전체 시스템 성능에 매우 중요한 영향을 미친다.
# 목차

1. 개요
2. 도메인과 하위 도메인
3. 도메인 모델
4. 도메인 모델 패턴과 아키텍처
5. 요구사항 기반 도메인 모델 도출
6. 실무 적용 사례
7. 마무리하며

---

> 이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 개요

소프트웨어 개발의 본질은 현실 세계의 문제를 해결하는 것이다. 이 문서에서는 소프트웨어가 해결하고자 하는 문제 영역인 **도메인(Domain)**의 개념을 정의하고, 이를 시스템으로 구현하기 위한 **도메인 모델(Domain Model)**의 설계 및 구현 방법을 다룬다.

---

### 2. 도메인과 하위 도메인

#### 2.1 도메인의 정의

**도메인**이란 소프트웨어를 통해 해결하고자 하는 문제 영역을 의미한다. 개발자는 단순히 코드를 작성하는 것을 넘어, 도메인 전문가와 지식을 공유하고 해당 도메인을 깊이 있게 이해해야 올바른 소프트웨어를 개발할 수 있다.

#### 2.2 하위 도메인 (Sub-domain)

하나의 큰 도메인은 여러 개의 **하위 도메인**으로 나뉠 수 있다. 예를 들어 ‘온라인 서점’이라는 도메인은 다음과 같은 하위 도메인으로 구성된다.

* 회원, 주문, 혜택
* 카탈로그, 리뷰
* 정산, 결제 등

---

### 3. 도메인 모델

#### 3.1 도메인 모델의 개념

**도메인 모델**은 특정 도메인을 개념적으로 표현한 것이다. 도메인이 제공하는 기능과 주요 데이터 구성을 파악하는 것이 중요하므로, 이를 동시에 표현할 수 있는 **객체 모델**이 모델링에 적합하다.

> **예시: 주문 도메인의 모델링**
> * **기능:** 상품 선택, 배송지 입력, 결제 수단 선택, 배송지 변경, 주문 취소 등
> * **데이터:** 상품 수량, 가격, 총 지불 금액, 배송지 정보 등
>
>

표현 방식보다는 도메인을 이해하는 데 실질적인 도움이 되는지가 중요하다.

#### 3.2 하위 도메인과 모델의 분리

같은 용어라도 하위 도메인에 따라 그 의미가 달라질 수 있다. 따라서 하위 도메인마다 별도의 모델을 만들어야 한다.

* **카탈로그 도메인의 '상품':** 가격, 상세 설명 등 정보를 담은 객체
* **배송 도메인의 '상품':** 고객에게 전달되는 물리적인 물품

---

### 4. 도메인 모델 패턴과 아키텍처

#### 4.1 계층형 아키텍처 (Layered Architecture)

일반적으로 애플리케이션 아키텍처는 역할에 따라 네 개의 영역으로 구분된다.

1. **사용자 인터페이스(표현 계층):** 사용자의 요청을 처리하고 정보를 보여준다.
2. **응용(Application):** 사용자 요청 기능을 실행하며, 업무 로직을 직접 구현하지 않고 도메인 계층을 조합한다.
3. **도메인(Domain):** 시스템이 제공할 **도메인 규칙**을 구현한다.
4. **인프라스트럭처(Infrastructure):** 데이터베이스, 메시징 시스템 등 외부 시스템과의 연동을 처리한다.

#### 4.2 도메인 계층의 역할

도메인 모델 패턴은 아키텍처 상의 도메인 계층을 객체 지향 기법으로 구현하는 것이다. 핵심은 **도메인의 핵심 규칙을 도메인 모델(객체) 내부에 구현**하는 점이다.

규칙이 모델 내부에 응집되어 있으면, 규칙이 변경되거나 확장될 때 다른 코드에 미치는 영향을 최소화할 수 있다.

```kotlin
/**
 * 도메인 규칙
 * - 주문 상태가 '배송 전'인 경우에만 배송지를 변경할 수 있다.
 * -  ... 
 */
class Order(
    val orderStatus: OrderStatus,
    var deliveryInfo: DeliveryInfo,
) {
    fun changeDeliveryInfo(deliveryInfo: DeliveryInfo) {
        if (!isChangeableDeliveryInfo()) {
            throw IllegalArgumentException(
                "배송 전인 상품만 배송지를 변경할 수 있습니다."
            )
        }
        this.deliveryInfo = deliveryInfo
    }
    
    private fun isChangeableDeliveryInfo(): Boolean {
        return this.orderStatus == OrderStatus.PREPARE
    }
}

data class DeliveryInfo(val address: String)

enum class OrderStatus {
    PREPARE, DELIVERED, CANCELLED
}

```

---

### 5. 요구사항 기반 도메인 모델 도출

도메인 모델링의 시작은 요구사항에서 핵심 구성요소, 규칙, 기능을 도출하는 것이다.

#### 5.1 주문 도메인 요구사항 예시

1. 최소 한 종류 이상의 상품을 주문해야 한다.
2. 한 상품을 한 개 이상 주문할 수 있다.
3. 총 주문 금액은 각 상품의 구매 가격 합(상품 가격 × 구매 개수)을 모두 더한 금액이다.
4. 주문 시 배송지 정보(이름, 전화번호, 주소)를 반드시 지정해야 한다.
5. 출고 후에는 배송지를 변경할 수 없다.
6. 출고 전에는 주문을 취소할 수 있다.
7. 결제 완료 전에는 상품을 준비하지 않는다.

#### 5.2 도메인 모델 구현

위 요구사항을 반영하여 설계한 `Order` 도메인 모델은 다음과 같다.

```kotlin
class Order(
    private var totalAmounts: Money,
    private var shippingInfo: ShippingInfo,
    private var state: OrderState,
) {
    private var orderLines: List<OrderLine> = emptyList()

		//	출고를 하면 배송지를 변경할 수 없다.
    fun changeShipped(newShippingInfo: ShippingInfo) {
	    verifyNotYetShipped()
	    this.shippingInfo = newShippingInfo
    }

		// 출고 전에 주문을 취소할 수 있다.
    fun cancel(newShippingInfo: ShippingInfo) {
        verifyNotYetShipped()
        this.state = OrderState.CANCELED
    }

    fun completePayment() {}

    private fun setOrderLines(orderLines: List<OrderLine>): List<OrderLine> {
		    // 최소 한 종류 이상의 상품을 주문해야 한다.
        verifyAtLeastOneOrMoreOrderLines(orderLines)
        this.orderLines = orderLines
        calculateTotalAmounts()
    }

    private fun verifyNotYetShipped() {
        if  (state != OrderState.PAYMENT_WAITING && state != OrderState.PREPARING) {
            throw IllegalStateException("already shipped")
        }
    }

    private fun verifyAtLeastOneOrMoreOrderLines(orderLines: List<OrderLine>) {
        if (orderLines.isEmpty()) {
            throw IllegalArgumentException("no OrderLine")
        }
    }

		// 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.
    private fun calculateTotalAmounts() {
        val sum = orderLines.sumOf { it.amounts }
        this.totalAmounts = Money(sum)
    }
}

data class OrderLine(
		// 각 상품은 한 개 이상 주문할 수 있다. 
    val product: Product,
    val price: Int,
    val quantity: Int,
) {
    val amounts: Int = calculateAmounts()

		// 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.
    private fun calculateAmounts(): Int {
        return price * quantity
    }
}

data class Money(val amount: Int)
data class Product(val id: String, val name: String, val price: Int)
// 배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.
data class ShippingInfo(
	val receiverName: String,
	val receiverPhoneNumber: String,
	val shippingAddress1: String,
  val shippingAddress2: String,
  val shippingZipCode: String
)
// 상태 관련 요구사항을 분석했을 때, 필요한 상태들
enum class OrderState {
    PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED, CANCELED
}

```

---

### 6. 실무 적용 사례

---

### 7. 마무리하며

도메인 모델은 단순한 데이터 저장소가 아니라, 비즈니스 로직과 규칙을 담고 있는 **소프트웨어의 핵심**이다. 요구사항을 분석하여 도메인 모델을 정교하게 설계하면 코드의 가독성과 유지보수성을 크게 높일 수 있다. 도메인 계층에 핵심 규칙을 집중시킴으로써 변화에 유연한 시스템을 구축하는 것이 도메인 모델링의 궁극적인 목표다.
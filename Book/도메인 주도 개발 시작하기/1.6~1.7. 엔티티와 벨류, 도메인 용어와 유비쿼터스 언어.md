# 목차

1. 개요
2. 밸류 타입 (Value Type)
3. 엔티티 식별자와 밸류 타입
4. 도메인 모델의 안정성: Setter 사용 지양
5. 도메인 용어와 유비쿼터스 언어
6. 실무 적용 사례
7. 요약

---

> 이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 개요

도메인 모델링에서 데이터의 의미를 명확히 하고 코드의 안전성을 높이기 위해 **밸류 타입(Value Type)**과 **유비쿼터스 언어(Ubiquitous Language)**를 사용하는 것은 매우 중요하다. 본 문서는 밸류 타입의 정의와 활용, 불변 객체의 중요성, 그리고 도메인 용어의 올바른 적용 방법에 대해 기술한다.

---

### 2. 밸류 타입 (Value Type)

#### 2.1 개념 및 정의

**밸류 타입**은 개념적으로 완전한 하나를 표현할 때 사용하는 객체다. 단순히 데이터를 담는 것을 넘어, 해당 데이터가 가진 의미를 명확하게 드러낸다.

#### 2.2 밸류 타입의 활용 예시

**1) 데이터 그룹화**
기존 `ShippingInfo` 클래스는 배송 정보를 담고 있지만, 내부 필드를 보면 '수령인 정보'와 '주소 정보'로 나눌 수 있다.

```kotlin
data class ShippingInfo(
	val receiverName: String,
	val receiverPhoneNumber: String,
	val shippingAddress1: String,
  val shippingAddress2: String,
  val shippingZipCode: String
)

```

이를 `Receiver`와 `Address`라는 밸류 타입으로 분리하면 의미가 더욱 명확해진다.

```kotlin
data class Receiver(val name: String, val phoneNumber: String) { ... }
data class Address(val address1: String, val address2: String, val zipCode: String) { ... }

```

**2) 의미 부여 (Primitive Type 캡슐화)**
`OrderLine`의 `price`나 `amounts`는 프로그래밍 언어의 숫자 타입(`Int`)이지만, 도메인 관점에서는 **‘돈’**을 의미한다.

```kotlin
// 변경 전: 단순 정수형 사용
data class OrderLine(
    val product: Product,
    val price: Int,
    val quantity: Int,
    val amounts: Int,
)

```

이를 `Money`라는 밸류 타입으로 정의하여 사용하면 코드가 더욱 직관적으로 변한다.

```kotlin
class Money(val value: Int) { ... }

// 변경 후: 밸류 타입 사용
data class OrderLine(
    val product: Product,
    val price: Money,
    val quantity: Int,
    val amounts: Money,
)

```

#### 2.3 밸류 타입의 기능과 불변성

밸류 타입은 단순한 데이터 컨테이너가 아니라, 도메인 로직을 포함할 수 있다. 예를 들어, 돈 계산 기능을 `Money` 객체 내부에 구현할 수 있다.

```kotlin
class Money(val value: Int) {
	fun add(money: Money): Money {
		return Money(this.value + money.value)
	}
}

```

이때 중요한 점은 **불변(Immutable)** 객체로 설계하는 것이다. `add` 메서드처럼 데이터를 변경해야 할 때, 내부 값을 수정하는 대신 변경된 값을 가진 **새로운 객체**를 반환해야 한다.

> **불변성이 중요한 이유: 안정성**
> 만약 밸류 타입이 변경 가능하다면(Mutable), 참조를 공유하는 여러 객체에서 의도치 않은 값 변경(Side Effect)이 발생할 수 있다.

```kotlin
// 가변 객체의 위험성 예시
val price: Money = Money(100)
val orderLine = OrderLine(product, price, 2)
price.value = 2000 // orderLine 내부의 price 값도 2000으로 바뀌어 데이터 무결성이 깨짐

```

---

### 3. 엔티티 식별자와 밸류 타입

엔티티의 식별자(ID)는 주로 문자열(`String`)이나 숫자(`Long`)로 구현되지만, 도메인적으로 특별한 의미를 지닌다(예: 주문번호, 카드번호 등). 식별자를 위한 별도의 밸류 타입을 사용하면 해당 필드의 의미가 명확해진다.

```kotlin
// String 타입 사용 시: id가 무엇을 의미하는지 문맥으로 유추해야 함
class Order(val id: String)

// 밸류 타입 사용 시: 타입 자체로 주문번호임을 알 수 있음
class Order(val id: OrderNo)
data class OrderNo(val id: String) {...}

```

---

### 4. 도메인 모델의 안정성: Setter 사용 지양

도메인 모델에 `get/set` 메서드를 무분별하게 추가하는 것은 좋지 않다. 특히 `set` 메서드(Setter)는 도메인의 의도를 흐리고 객체의 안정성을 해친다.

#### 4.1 이유 1: 의미의 불명확성

`set` 메서드는 단순히 값을 변경한다는 의미만 전달할 뿐, **‘왜’** 변경하는지 도메인 의도를 드러내지 못한다.

```kotlin
// 좋지 않은 예: 단순히 값만 설정
class Order {
	fun setShippingInfo(shippingInfo: ShippingInfo) { ... }
	fun setOrderState(orderStatus: OrderStatus) { ... }
}

```

위 코드를 도메인 용어에 맞게 수정하면 다음과 같이 의도가 명확해진다.

* `setShippingInfo` → **`changeShippingInfo`** (배송지 변경)
* `setOrderState` → **`completePayment`**, **`cancel`** (결제 완료, 취소 등 구체적 행위)

또한, 상태 값에 따라 추가 로직(예: 결제 완료 시 이벤트 발행)이 필요한 경우, 단순 Setter로는 이를 표현하기 어렵다.

#### 4.2 이유 2: 불완전한 객체 생성 위험

Setter를 통해 데이터를 주입하게 되면, 객체 생성 시점에 필수 데이터가 누락되어 **불완전한 상태(Incomplete State)**로 존재할 수 있다.

```kotlin
val order = Order()
order.setOrderLines(lines)
order.setShippingInfo(shippingInfo)
order.setState(OrderState.PREPARING)  // 주문자 정보가 누락되었음에도 로직 수행 가능

```

객체가 생성되는 시점에 필요한 모든 정보를 생성자(Constructor)를 통해 전달받아, 생성되자마자 온전한 상태를 보장해야 한다.

---

### 5. 도메인 용어와 유비쿼터스 언어

#### 5.1 유비쿼터스 언어(Ubiquitous Language)의 정의

유비쿼터스 언어란 도메인 전문가, 관계자, 개발자가 도메인과 관련된 **공통의 언어**를 정의하고 이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 일관되게 사용하는 것을 말한다.

#### 5.2 코드에 도메인 용어 반영하기

코드를 작성할 때는 도메인에서 사용하는 용어를 그대로 반영해야 한다. 모호한 용어 사용은 코드 해석 비용을 높인다.

```kotlin
// 좋지 않은 예: 도메인 의미를 알 수 없는 상태 값
enum class OrderState() {
	STEP1, STEP2, STEP3, ...
}

```

위와 같은 코드는 `STEP1`이 무엇을 의미하는지 다시 확인해야 한다. 이를 유비쿼터스 언어로 변경하면 직관적인 이해가 가능하다.

* `STEP1` → `PAYMENT_WAITING` (결제 대기)
* `STEP2` → `PREPARING` (상품 준비 중)

이렇게 하면 소통 과정의 오해를 줄이고, 개발자가 도메인과 코드 사이를 번역하는 불필요한 노력을 제거할 수 있다.

---

### 6. 실무 적용 사례

---

### 7. 요약

밸류 타입은 도메인의 개념을 명확히 표현하고 불변성을 통해 데이터의 안정성을 보장한다. 도메인 모델에서는 의도가 불명확한 Setter 대신 구체적인 행위를 나타내는 메서드를 사용해야 하며, 생성 시점에 완전한 상태를 갖추도록 해야 한다. 또한, 유비쿼터스 언어를 사용하여 코드와 도메인 지식 간의 간극을 줄이는 것이 유지보수성 높은 소프트웨어를 만드는 핵심이다.
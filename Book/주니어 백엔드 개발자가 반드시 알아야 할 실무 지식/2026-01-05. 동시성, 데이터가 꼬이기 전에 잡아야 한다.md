# 목차

1. 개요

   1.1 서버와 동시 실행

   1.2 경쟁 상태(Race Condition)

2. 프로세스 수준의 동시성 제어 (JVM)

   2.1 잠금(Lock)과 임계 영역

   2.2 Java/Kotlin의 잠금 구현체

   2.3 가상 스레드(Virtual Thread) 환경의 잠금

   2.4 기타 동기화 도구 (Semaphore, Read/Write Lock)

3. 잠금 없는(Lock-free) 동시성 제어

   3.1 원자적 타입(Atomic Type)

   3.2 동시성 컬렉션

   3.3 불변 객체(Immutable Object)

4. 데이터베이스 수준의 동시성 제어

   4.1 선점 잠금 (비관적 잠금)

   4.2 비선점 잠금 (낙관적 잠금)

   4.3 증분 쿼리(Atomic Update)

5. **외부 시스템 연동 시 고려사항**
6. **실무 적용 사례**
7. **요약**

---

이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 개요

### 1.1 서버와 동시 실행

현대 서버 애플리케이션에서 **동시 처리(Concurrent Processing)** 는 필수 불가결한 요소다. 여러 클라이언트의 요청을 순차적으로 처리한다면 전체 처리량(Throughput)이 저하되고 응답 시간이 급격히 증가하기 때문이다. 그러나 동시에 동일한 데이터를 조회하거나 수정하는 과정에서 데이터 무결성이 훼손될 위험이 존재한다.

### 1.2 경쟁 상태(Race Condition)

**경쟁 상태**란 여러 스레드(또는 프로세스)가 동시에 **공유 자원**에 접근할 때, 실행 순서나 타이밍에 따라 **결과가 달라지는 현상**을 의미한다.

- 경쟁 상태 자체는 에러가 아니지만, **잘못된 결과를 초래할 수 있는 불안정한 상태**다.
- 동시성 문제의 대부분은 이러한 경쟁 상태를 적절히 제어하지 못했을 때 발생한다.

---

### 2. 프로세스 수준의 동시성 제어 (JVM)

단일 프로세스(JVM) 내부에서 여러 스레드가 메모리, 객체 등의 공유 자원에 접근할 때는 반드시 접근 제어가 필요하다.

### 2.1 잠금(Lock)과 임계 영역

**잠금(Lock)** 은 공유 자원에 대한 접근 권한을 한 번에 하나의 스레드로 제한하는 메커니즘이다.

- **임계 영역(Critical Section):** 둘 이상의 스레드가 동시에 접근해서는 안 되는 코드 영역이다. 이 영역은 반드시 잠금으로 보호되어야 하며, 그렇지 않을 경우 데이터 불일치가 발생한다.
- **동작 원리:** 스레드는 잠금을 획득해야만 임계 영역에 진입할 수 있으며, 작업이 끝나면 잠금을 해제하여 대기 중인 다른 스레드가 진입할 수 있게 한다.
- **특징:** 잠금 범위가 넓을수록 안전하지만 성능이 저하되고, 좁을수록 성능은 유리하나 데드락(Deadlock) 등 설계 난이도가 높아진다.

### 2.2 Java/Kotlin의 잠금 구현체

1) synchronized

JVM 레벨에서 제공하는 가장 기본적인 잠금 방식으로, 메서드나 블록 단위로 사용한다.

```java
synchronized (lockObject) {
    // 임계 영역
}
```

- **장점:** 문법이 단순하며, 예외 발생 시 자동으로 잠금이 해제되어 안전하다.
- **단점:** 대기 시간 설정, 인터럽트 처리, 공정성 부여 등 세밀한 제어가 불가능하다.

2) ReentrantLock

java.util.concurrent.locks 패키지에서 제공하는 명시적 잠금 클래스다.

```kotlin
val lock = ReentrantLock()
lock.lock()
try {
    // 임계 영역
} finally {
    lock.unlock()
}
```

- **장점:** 대기 시간 제한(`tryLock`), 인터럽트 허용, 공정성 설정 등 고급 기능을 제공한다.
- **단점:** `finally` 블록에서 `unlock()`을 직접 호출해야 하므로 구현 실수(잠금 누수)의 위험이 있다.

### 2.3 가상 스레드(Virtual Thread) 환경의 잠금

Java 21에 도입된 가상 스레드 환경에서는 블로킹 방식이 성능에 큰 영향을 미친다.

- **`synchronized`:** 가상 스레드에서 사용 가능하지만, 특정 상황에서 **캐리어 스레드를 점유(Pinning)** 하여 확장성을 저해할 수 있다.
- **`ReentrantLock`:** 가상 스레드 친화적으로 설계되어 있어 예측 가능한 동작을 보장하므로, 가상 스레드 환경에서는 사용이 권장된다.

> 참고: 가상 스레드 환경에서도 락의 종류보다 락의 점유 시간과 범위를 최적화하는 것이 성능에 더 중요한 요소다.
>

### 2.4 기타 동기화 도구

1) 세마포어(Semaphore)

동시에 자원에 접근할 수 있는 스레드의 수(Permit) 를 제한하는 도구다. 상호 배제보다는 유량 제어(Throttling) 에 적합하다.

```kotlin
val semaphore = Semaphore(5) // 동시 접근 5개 허용

fun callExternalApi() {
    semaphore.acquire()
    try { /* 외부 API 호출 */ } finally { semaphore.release() }
}
```

2) 읽기/쓰기 잠금(Read/Write Lock)

읽기 작업이 빈번하고 쓰기 작업이 적은 경우 효율적이다. ReentrantReadWriteLock이 대표적이다.

- **읽기 잠금:** 여러 스레드 동시 획득 가능.
- **쓰기 잠금:** 단일 스레드만 획득 가능(배타적). 쓰기 잠금 중에는 읽기도 불가능하다.

---

### 3. 잠금 없는(Lock-free) 동시성 제어

잠금은 대기(Blocking)를 유발하므로, 경쟁이 심한 경우 성능 저하의 원인이 된다. 이를 피하기 위한 기법들은 다음과 같다.

### 3.1 원자적 타입(Atomic Type)

`AtomicInteger`, `AtomicReference` 등은 CAS(Compare-And-Swap) 알고리즘을 사용하여 잠금 없이도 단일 변수의 스레드 안전성을 보장한다. 단순 카운팅이나 플래그 관리에 매우 적합하다.

### 3.2 동시성 컬렉션

기본 컬렉션(`ArrayList`, `HashMap`)은 스레드에 안전하지 않다.

- **동기화된 컬렉션:** `Collections.synchronizedMap` 등은 모든 접근에 잠금을 걸어 성능이 떨어진다.
- **동시성 컬렉션:** `ConcurrentHashMap`, `CopyOnWriteArrayList` 등은 잠금 분할(Lock Striping)이나 불변성 활용을 통해 높은 성능을 제공한다. 실무에서는 주로 `ConcurrentHashMap`을 사용한다.

### 3.3 불변 객체(Immutable Object)

상태가 변하지 않는 객체는 동시성 문제가 원천적으로 발생하지 않는다. Kotlin의 `val`, `data class` 등을 활용하여 가능한 한 공유 상태를 불변으로 설계하는 것이 가장 안전한 방법이다.

---

### 4. 데이터베이스 수준의 동시성 제어

애플리케이션 레벨의 잠금은 다중 서버 환경에서 DB 데이터의 정합성을 보장하지 못한다. 따라서 DB 자체의 동시성 제어 기능이 필요하다.

### 4.1 선점 잠금 (비관적 잠금, Pessimistic Lock)

데이터 충돌 가능성이 높다고 가정하고, 데이터를 조회하는 시점에 **먼저 잠금을 획득**하는 방식이다. (`SELECT ... FOR UPDATE`)

- **특징:** 강력한 데이터 정합성을 보장하지만, 잠금 대기로 인해 처리량이 저하될 수 있다.
- **분산 락과의 차이:** DB 비관적 잠금은 DB 리소스를 잠그는 것이며, Redis 등을 이용한 **분산 락(Distributed Lock)** 은 애플리케이션 전반의 논리적 자원을 제어하는 것이다.

### 4.2 비선점 잠금 (낙관적 잠금, Optimistic Lock)

충돌 가능성이 낮다고 가정하고, **수정 시점에 버전을 검증**하여 충돌을 감지하는 방식이다.

- **동작:** `version` 컬럼을 확인하여 조회 시점과 수정 시점의 버전이 다르면 예외를 발생시킨다(또는 수정 행 개수 0).
- **특징:** 별도의 DB 잠금을 점유하지 않아 성능이 우수하지만, 충돌 발생 시 **재시도 로직**을 직접 구현해야 한다.

### 4.3 증분 쿼리(Atomic Update)

데이터를 조회해서 수정 후 저장하는 것이 아니라, DB의 연산 기능을 직접 이용한다.

```sql
UPDATE SUBJECT SET join_count = join_count + 1 WHERE id = 1;
```

- 잠금 없이도 안전하고 빠르지만, 복잡한 검증 로직(`if count < max`)이 필요한 경우 `WHERE` 절에 조건을 추가하여 보완해야 한다.

---

### 5. 외부 시스템 연동 시 고려사항

외부 API 호출이나 메시지 발행은 DB 트랜잭션과 달리 **롤백이 불가능**하다.

- **문제점:** 트랜잭션 내에서 외부 호출 후 DB 롤백이 발생하면 데이터 불일치가 생긴다. 낙관적 잠금 사용 시 커밋 시점에야 실패를 알 수 있어 외부 호출이 이미 실행되었을 위험이 있다.
- **해결책:**
    1. **비관적 잠금:** 외부 호출 전 데이터를 선점하여 다른 요청을 차단한다. (단, 성능 저하 주의)
    2. **트랜잭션 아웃박스 패턴:** DB에 '이벤트'를 먼저 저장하고, 별도 프로세스가 외부 통신을 수행하여 일관성을 보장한다.

---

### 6. 실무 적용 사례
(추후 적용 예정)
---

### 7. 요약

서버 환경에서 동시성 제어는 시스템의 신뢰성을 결정짓는 핵심 기술이다.

- **JVM 내부**에서는 불변 객체와 동시성 컬렉션을 우선 고려하고, 필요시 `ReentrantLock`이나 `synchronized`를 적절히 사용한다.
- **DB 연동** 시에는 충돌 빈도와 비즈니스 중요도에 따라 비관적 잠금(안전성)과 낙관적 잠금(성능)을 선택한다.
- **외부 연동**이 포함된 경우 단순 잠금을 넘어 아웃박스 패턴 등 정교한 설계가 필요하다.

결국 모든 동시성 제어 기법은 **상호 대체재가 아니라, 상황에 맞춰 조합해야 하는 상호 보완재**임을 명심해야 한다.
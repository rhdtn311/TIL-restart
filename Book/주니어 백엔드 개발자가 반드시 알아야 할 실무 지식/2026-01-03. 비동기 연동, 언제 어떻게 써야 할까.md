목차

1. [개요](https://www.google.com/search?q=%231-%EA%B0%9C%EC%9A%94)
2. [동기 연동과 비동기 연동](https://www.google.com/search?q=%232-%EB%8F%99%EA%B8%B0-%EC%97%B0%EB%8F%99%EA%B3%BC-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%97%B0%EB%8F%99)
3. [비동기 처리 구현: 스레드 활용](https://www.google.com/search?q=%233-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC-%EA%B5%AC%ED%98%84-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%9C%EC%9A%A9)
4. [비동기 처리 구현: 메시징 시스템](https://www.google.com/search?q=%234-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC-%EA%B5%AC%ED%98%84-%EB%A9%94%EC%8B%9C%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C)
5. [데이터 정합성 보장 패턴](https://www.google.com/search?q=%235-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%ED%95%A9%EC%84%B1-%EB%B3%B4%EC%9E%A5-%ED%8C%A8%ED%84%B4)
6. [대량 데이터 처리 방식](https://www.google.com/search?q=%236-%EB%8C%80%EB%9F%89-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EC%8B%9D)
7. [실무 적용 사례](https://www.google.com/search?q=%237-%EC%8B%A4%EB%AC%B4-%EC%A0%81%EC%9A%A9-%EC%82%AC%EB%A1%80)
8. [요약](https://www.google.com/search?q=%238-%EC%9A%94%EC%95%BD)

---

이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. 개요

시스템 간 연동 및 내부 로직 처리는 크게 동기(Synchronous) 방식과 비동기(Asynchronous) 방식으로 나뉜다. 각 방식의 특성을 이해하고 상황에 맞는 적절한 처리 방식을 선택하는 것은 시스템의 안정성과 성능을 보장하는 데 필수적이다. 본 문서는 두 방식의 차이점과 비동기 처리의 구체적인 구현 방법, 그리고 데이터 정합성을 위한 패턴을 다룬다.

---

### 2. 동기 연동과 비동기 연동

### 2.1 동기(Synchronous) 방식

작업이 순차적으로 실행되는 방식이다. 요청을 보낸 후 응답이 올 때까지 대기한다.

- **장점:** 프로그램의 흐름을 직관적으로 이해하기 쉽고 디버깅이 용이하다.
- **외부 연동 시 고려사항:**
    - 외부 시스템의 장애가 전체 기능의 실패로 이어질 수 있다.
    - 외부 연동 실패가 전체 트랜잭션의 실패로 처리되어야 하는지 확인이 필요하다.

### 2.2 비동기(Asynchronous) 방식

한 작업이 끝나기를 기다리지 않고 즉시 다음 작업을 처리하는 방식이다.

- **특징:**
    - 연동 간에 약간의 시차가 발생해도 무방한 경우 적합하다.
    - 실패 시 재시도가 가능하거나, 추후 수동 처리가 가능한 기능에 유용하다.
    - 실패를 무시해도 되는 기능(예: 단순 푸시 알림)에 효과적이다.
- **도입 기준:** 반드시 외부 연동 결과가 즉시 필요한 것이 아니라면 비동기 방식을 고려하는 것이 효율적이다.

---

### 3. 비동기 처리 구현: 스레드 활용

애플리케이션 레벨에서 별도의 스레드를 생성하여 작업을 병렬로 처리하는 방법이다.

### 3.1 구현 방법

- **스레드 풀(Thread Pool):** 스레드를 미리 생성해 두고 재사용하여 작업을 처리한다.
- **프레임워크 지원:** Spring 프레임워크에서는 `@Async` 애노테이션을 사용하여 간편하게 비동기 메서드를 구현할 수 있다.

### 3.2 주의사항

> 스레드 사용 시 트랜잭션 관리와 예외 처리에 유의해야 한다.
>
- **예외 처리:** 메인 스레드의 `try-catch` 블록에서 비동기 스레드의 예외가 잡히지 않는다.
- **트랜잭션 전파 불가:** `@Transactional`을 사용하더라도 비동기 스레드에서 발생한 에러는 메인 트랜잭션의 롤백을 유발하지 않는다.
- **리소스 관리:**
    - 스레드는 자체적으로 일정 메모리(최소 수백 KB)를 점유하므로 과도한 생성은 메모리 부족을 야기할 수 있다.
    - 스레드 생성 비용(시간)이 소요되므로, JDK 21 이상의 가상 스레드(Virtual Thread) 도입을 고려해볼 수 있다.

---

### 4. 비동기 처리 구현: 메시징 시스템

시스템 A가 시스템 B를 직접 호출하지 않고, 중간에 **메시지 브로커(Message Broker)**를 두어 통신하는 방식이다.

### 4.1 특징 및 장점

- **느슨한 결합(Decoupling):** 두 시스템이 서로 직접적인 영향을 주지 않는다. 시스템 B의 장애나 성능 저하가 시스템 A에 전파되지 않는다.
- **확장성(Scalability):** 시스템 A의 코드 수정 없이 구독자(시스템 C 등)를 쉽게 추가할 수 있다.
- **주요 솔루션:** Apache Kafka, RabbitMQ, Redis Pub/Sub 등

### 4.2 생산자(Producer) 고려사항

메시지를 생성하고 전송하는 측에서 고려해야 할 요소다.

- **메시지 유실 방지:**
    - 타임아웃 등으로 전송 실패 시 정책을 수립해야 한다.
    - **무시:** 로그 데이터 등 유실이 허용되는 경우.
    - **재시도:** 메시지 전송을 다시 시도하되, 중복 전송 가능성을 고려해야 한다.
    - **실패 로그:** 별도 저장소에 기록 후 추후 수동/자동으로 후처리한다.
- **DB 트랜잭션과의 정합성:**
    - 비즈니스 로직(DB 커밋)은 성공했으나 메시지 전송이 실패하면 데이터 불일치가 발생한다.
    - 반드시 트랜잭션 커밋 후 메시지를 전송하거나, **글로벌 트랜잭션**(예: ActiveMQ 지원)을 사용해야 한다. 단, 글로벌 트랜잭션은 성능 저하를 유발하므로 신중히 사용해야 한다.

### 4.3 소비자(Consumer) 고려사항

메시지를 수신하고 처리하는 측에서 고려해야 할 요소다.

- **멱등성(Idempotency) 보장:** 메시지 중복 수신 시에도 시스템 상태가 동일하게 유지되어야 한다.
    - **고유 ID 활용:** 생산자가 부여한 고유 ID를 통해 이미 처리된 메시지인지 확인한다.
    - **API 구현:** 재수신 후 처리 과정에서 외부 API를 중복 호출하지 않도록 방어 로직을 작성한다.

### 4.4 메시지 종류

- **이벤트(Event):** 과거형으로 표현되며, 사실의 발생을 알린다. (예: `OrderPlaced`, `LoginFailed`) 수신자가 특정되지 않은 브로드캐스트 성격이다.
- **커맨드(Command):** 특정 동작을 요청하며 수신자가 명확하다. (예: `SendNotification`, `BlockUser`)

> 참고: 궁극적 일관성(Eventual Consistency)
>
>
> 분산 시스템에서는 데이터가 즉시 일치하지 않더라도, 일정 시간이 지나면 결국 일관성이 맞춰지는 모델을 채택한다. 메시징 시스템은 이 모델을 기반으로 동작한다.
>

---

### 5. 데이터 정합성 보장 패턴

### 5.1 트랜잭션 아웃박스 패턴 (Transactional Outbox Pattern)

![image.png](attachment:f94aa09d-042f-4482-b720-d8109aab75dd:image.png)

메시지 전송 실패로 인한 데이터 유실을 방지하기 위해 사용한다.

- **핵심 원리:** 메시지를 브로커에 직접 보내는 대신, 비즈니스 트랜잭션 내에서 **'아웃박스 테이블'**에 메시지를 저장한다. DB 트랜잭션이 커밋되면 메시지도 안전하게 저장된다.
- **동작 방식:**
    1. 비즈니스 로직 수행과 메시지 저장(Insert)을 하나의 트랜잭션으로 묶는다.
    2. 별도의 중계 프로세스(Poller)가 아웃박스 테이블을 주기적으로 읽어 메시지 브로커로 전송한다.
    3. 전송 완료 후 메시지 상태를 업데이트하거나 삭제한다.
- **테이블 구조:** `id`, `messageId`, `messageType` (예: LoginFailed), `payload`, `status` 등으로 구성한다.
- **상태 관리:** 일시적인 실패는 재시도 처리하고, 반복 실패 시에만 '실패(Failed)' 상태로 변경하여 관리한다.

---

### 6. 대량 데이터 처리 방식

### 6.1 배치 전송 (Batch Processing)

일정 간격으로 데이터를 모아서 처리하는 전통적인 방식이다.

- **프로세스:** DB 조회 → 파일 기록(CSV, JSON 등) → 파일 전송(FTP/SFTP)
- **재처리 전략:** 배치 작업은 시간이 오래 걸리므로, 실패 시 처음부터 다시 실행하기보다 실패 지점부터 재시작하거나 수동으로 재실행할 수 있는 API를 확보해야 한다.

### 6.2 CDC (Change Data Capture)

DBMS의 변경 로그(예: MySQL Binlog)를 감지하여 데이터 변경 사항을 실시간으로 전파하는 기술이다.

- **동작 원리:** DB 변경 발생 → CDC 처리기 감지 → 데이터 가공 → 메시징 시스템 → 소비자
- **장점:** 서비스 코드를 수정하지 않고도 데이터 변경을 감지하여 타 시스템(검색 엔진, 캐시 등)에 전파할 수 있다.
- **주의사항:**
    - **의미 전달의 한계:** CDC는 데이터 값의 변화(Password: A -> B)만 전달할 뿐, 비즈니스적 의미("비밀번호 초기화됨")를 명확히 담기 어렵다. 이를 보완하기 위해 상태 컬럼을 활용할 수 있다.
    - **오프셋(Offset) 관리:** CDC 처리기가 중단 후 재시작될 때, 마지막으로 읽은 시점부터 데이터를 처리할 수 있도록 진행 상황을 기록해야 한다.

---

### 7. 실무 적용 사례

(추후 적용 예정)

---

### 8. 요약

시스템 연동 시에는 즉각적인 응답이 필요한 경우 **동기 방식**을, 결합도를 낮추고 성능을 확보해야 하는 경우 **비동기 방식**을 선택해야 한다. 비동기 처리는 **스레드**나 **메시징 시스템**을 통해 구현하며, 데이터 유실을 방지하기 위해 **트랜잭션 아웃박스 패턴**을 적용하는 것이 안전하다. 대량 데이터 처리가 필요할 때는 **배치** 혹은 실시간성이 중요한 경우 **CDC**를 적절히 활용하여 시스템의 목적에 맞는 아키텍처를 설계해야 한다.
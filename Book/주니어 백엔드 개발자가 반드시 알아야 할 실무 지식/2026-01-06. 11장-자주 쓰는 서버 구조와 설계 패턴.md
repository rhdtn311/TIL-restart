목차

1. MVC 패턴
2. 계층형 아키텍처 (Layered Architecture)
3. DDD와 전술 패턴
4. 마이크로서비스 아키텍처 (MSA)
5. 이벤트 기반 아키텍처 (EDA)
6. CQRS 패턴
7. 실무 적용 사례
8. 요약

---

이 문서는 사용자의 초안을 바탕으로 Gemini가 체계적으로 구조화하고 내용을 다듬어 작성했다.

---

### 1. MVC 패턴

- MVC(Model-View-Controller)는 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 및 유지보수의 효율성을 높이는 디자인 패턴이다.

### 1.1 주요 구성 요소

- **모델 (Model):** 비즈니스 영역의 로직을 처리한다. 데이터의 상태를 관리하고 비즈니스 규칙을 수행한다.
- **뷰 (View):** 사용자에게 보여질 결과(UI)를 생성하여 응답한다.
- **컨트롤러 (Controller):** 사용자의 입력을 처리하고 흐름을 제어한다.
    - 사용자의 요청을 해석하여 적절한 **모델**을 호출한다.
    - 처리 결과를 보여줄 **뷰**를 선택한다.
    - 비즈니스 로직과 무관한 인증, 검증 등의 기능을 수행한다.

### 1.2 핵심 원칙

- **관심사의 분리:** 비즈니스 로직(모델)과 화면 표현(뷰)을 명확히 분리한다.
- **흐름 제어 집중:** 애플리케이션의 흐름 제어와 요청 처리는 컨트롤러가 전담한다.
- **상호 독립성:** 모델과 뷰가 분리되어 있어, 한 쪽의 변경 사항이 다른 쪽에 영향을 주지 않는다.

---

### 2. 계층형 아키텍처 (Layered Architecture)

시스템을 유사한 관심사끼리 묶어 수평적인 계층으로 나누어 구성하는 아키텍처다. 각 계층은 특정 역할을 수행하며, **하위 계층에만 의존**하는 단방향 의존성을 가진다.

### 2.1 4계층 구조 (일반적인 웹 애플리케이션)

1. **표현 계층 (Presentation):** 사용자와의 상호작용을 담당한다.
2. **응용 계층 (Application):** 사용자의 요청을 처리하고 결과를 표현 계층에 반환한다.
3. **도메인 계층 (Domain):** 핵심 비즈니스 로직(도메인 로직)을 구현한다.
4. **인프라 계층 (Infrastructure):** DB 연동, 메시지 발송 등 구체적인 구현 기술을 지원한다.

### 2.2 한계점: 흩어지는 도메인 로직

- 일반적으로 도메인 계층을 제외한 3계층(표현, 응용, 인프라) 위주로 개발되는 경향이 있다.
- 이 경우 도메인 로직이 응용 계층이나 인프라 계층으로 분산되어 코드의 응집도가 낮아지고 **유지보수가 어려워지는 문제**가 발생한다.

---

### 3. DDD와 전술 패턴

- *DDD(Domain-Driven Design)**는 복잡한 도메인을 효과적으로 구현하기 위한 설계 방법론이다. 전술 패턴을 활용하면 도메인 로직을 도메인 영역에 집중시켜 유지보수성을 높일 수 있다.

### 3.1 핵심 목표

- 복잡한 모델을 **애그리거트(Aggregate)** 단위로 관리하여 복잡도를 낮춘다.
- 관련 로직을 애그리거트에 모아 **응집도**를 높인다.

### 3.2 주요 구성 요소

| **구성 요소** | **설명** |
| --- | --- |
| **엔티티 (Entity)** | 고유의 식별자를 가지며, 내부 상태가 변경되어도 식별자를 통해 동일한 객체로 인식된다. |
| **밸류 (Value)** | 고유 식별자 없이 개념적인 값을 표현한다(예: 금액, 주소). 불변(Immutable) 객체로 구현하는 것이 권장된다. |
| **애그리거트 (Aggregate)** | 관련 객체(엔티티+밸류)를 묶은 하나의 개념적 단위다. 모델의 일관성을 관리하는 경계가 된다. (예: 주문 = Order 엔티티 + OrderLine 밸류 등) |
| **리포지토리 (Repository)** | 도메인 객체를 영속화(저장/조회)하는 인터페이스다. 애그리거트 단위로 존재하며 도메인과 인프라를 연결한다. |
| **도메인 서비스 (Domain Service)** | 특정 애그리거트에 속하지 않거나 외부 연동이 필요한 로직을 구현한다. |
| **도메인 이벤트 (Domain Event)** | 도메인 상태 변경 시 발생하는 사건을 표현한다. 주로 다른 시스템이나 모듈에 변화를 알리기 위해 사용된다. |

---

### 4. 마이크로서비스 아키텍처 (MSA)

애플리케이션을 **독립적으로 배포 가능한 작은 서비스 단위**로 나누어 구축하는 아키텍처다.

[Microservices vs Monolithic Architecture 이미지](https://encrypted-tbn3.gstatic.com/licensed-image?q=tbn:ANd9GcTC166plymW1DQ25yjS6javLT8t4sQ_YEDQ2umDKo-ukJTnuLlQ4XAJrynVbIOlCJmv64cSHl95E-giS_HGqo8dSThDYxQRP21y462yGkRn_wONuRQ)

Shutterstock

### 4.1 핵심 개념

- **독립적 배포:** 특정 서비스의 변경 및 배포가 다른 서비스에 영향을 주지 않아야 한다.
- **도메인 중심 모델링:** 기술이 아닌 비즈니스 도메인 경계를 기준으로 서비스를 나눈다.
- **독자적인 상태 관리:** 각 마이크로서비스는 전용 DB를 가지며, 타 서비스의 데이터는 API를 통해서만 접근한다.
- **유연성:** 비용을 투자하여 기술적 다양성, 확장성, 견고함을 얻는 구조다.
- **콘웨이의 법칙:** 조직 구조가 시스템 아키텍처에 반영되므로, 비즈니스 도메인이 아키텍처를 주도하도록 조직을 구성해야 한다.

### 4.2 모놀리식 vs 마이크로서비스 비교

| **구분** | **모놀리식 (Monolithic)** | **마이크로서비스 (Microservices)** |
| --- | --- | --- |
| **장점** | 배포 및 코드 관리 용이
테스트/디버깅 쉬움
단순한 구조로 인한 초기 성능 이점 | 독립적/지속적 배포 용이
개별 서비스 성능 확장 용이
기술 스택 선택의 유연성 |
| **단점** | 규모 증가 시 개발 속도 저하
부분 장애가 전체로 확산
작은 변경에도 전체 재배포 필요 | 테스트 및 디버깅의 어려움
인프라 구성 복잡도 증가
서비스 간 통신 비용 발생 |

---

### 5. 이벤트 기반 아키텍처 (EDA)

시스템 간의 통신을 **이벤트(과거에 발생한 사실)**를 통해 비동기적으로 처리하는 구조다.

### 5.1 구성 요소

- **생산자 (Producer):** 이벤트를 생성하여 브로커에게 전달한다.
- **소비자 (Consumer):** 브로커로부터 이벤트를 전달받아 처리한다.
- **브로커 (Broker):** 이벤트를 중개하는 라우터 역할을 한다. (대표적 기술: Kafka)

### 5.2 주요 특징

- **느슨한 결합:** 생산자와 소비자가 브로커를 통해 간접적으로 연결되므로 상호 의존성이 낮고 독립적인 배포가 가능하다.
- **확장성:** 새로운 소비자를 추가하기 쉬워 시스템 확장에 유리하다.
- **단일 진실 공급원 (Single Source of Truth):** Kafka와 같이 이벤트를 영구 보관할 수 있는 브로커를 사용하면, 이벤트 로그만으로 시스템의 모든 상태 변화를 추적할 수 있다.

---

### 6. CQRS 패턴

- *CQRS(Command Query Responsibility Segregation)**는 데이터의 상태를 변경하는 **명령(Command)** 모델과 데이터를 조회하는 **조회(Query)** 모델을 분리하는 패턴이다.

### 6.1 도입 배경

- 데이터 생성 시 필요한 정보(예: 회원 ID, 상품 ID)와 조회 시 필요한 정보(예: 회원명, 상품명)가 상이하다.
- 단일 모델로 처리할 경우 로직이 복잡해지고 유지보수가 어려워진다.

### 6.2 장단점 분석

- **장점:**
    - 각 기능(명령/조회)에 최적화된 모델을 구현할 수 있다.
    - 조회 모델에만 캐시를 적용하거나 별도 조회 전용 DB를 구축하여 성능을 극대화할 수 있다.
- **단점:**
    - 구현해야 할 코드 양과 관리해야 할 모델이 늘어난다.
    - 명령 DB와 조회 DB를 분리할 경우 데이터 동기화 등 기술적 복잡도가 증가한다.

---

### 7. 실무 적용 사례

현대의 대규모 시스템(예: 이커머스, 배달 플랫폼)에서는 위에서 언급한 개념들을 복합적으로 적용하여 구축한다.

> 시나리오: 온라인 주문 시스템
>
1. **MSA & Layered Architecture:** 주문 서비스, 배송 서비스, 회원 서비스가 각각 별도의 마이크로서비스로 분리되어 있으며, 각 서비스 내부는 계층형 아키텍처를 따른다.
2. **DDD:** 주문 서비스 내부에서는 '주문'을 **애그리거트**로 정의하고, 주문 상태 변경 로직을 도메인 모델 내에 집중시킨다.
3. **EDA:** 사용자가 '주문 완료'를 클릭하면 주문 서비스는 DB에 저장 후 `OrderCreated` **이벤트**를 Kafka에 발행한다. 배송 서비스(소비자)는 이 이벤트를 수신하여 배송 준비를 시작한다. 이를 통해 서비스 간 결합도를 낮춘다.
4. **CQRS:** 주문 내역 조회 화면은 트래픽이 많으므로, 주문 생성(Command) 로직과 분리하여 조회 전용 모델(Query)을 통해 빠르게 데이터를 제공한다. 조회 모델은 NoSQL이나 캐시(Redis)를 활용해 성능을 높인다.

---

### 8. 요약

소프트웨어 아키텍처는 복잡성을 제어하고 유지보수성을 높이는 방향으로 발전해 왔다. **MVC**와 **계층형 아키텍처**는 관심사의 분리를 통해 코드의 구조를 잡고, **DDD**는 비즈니스 로직의 응집도를 높여 복잡한 도메인을 해결한다. 더 나아가 **MSA**와 **EDA**, **CQRS**는 시스템의 확장성과 유연성을 확보하기 위해 컴포넌트 간의 의존성을 끊고 데이터를 효율적으로 처리하는 데 중점을 둔다.